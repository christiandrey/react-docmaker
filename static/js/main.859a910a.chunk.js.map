{"version":3,"sources":["../../src/core/constants/index.ts","../../src/core/utils/index.ts","../../src/core/tools/index.ts","../../src/modules/button/index.tsx","../../src/modules/header/index.tsx","../../src/core/contexts/orphan-nodes.ts","../../src/modules/template-editor/index.tsx","../../src/modules/elements/image/index.tsx","../../src/modules/elements/editable/index.tsx","../../src/modules/elements/table/utils/selection.ts","../../src/modules/elements/table/utils/options.ts","../../src/modules/elements/table/modules/horizontal-toolbar/index.tsx","../../src/modules/elements/table/modules/vertical-toolbar/index.tsx","../../src/modules/elements/table/modules/table-body/index.tsx","../../src/modules/elements/table/utils/commands.ts","../../src/core/hooks/index.ts","../../src/modules/icon/index.tsx","../../src/modules/icon-button/index.tsx","../../src/modules/icon-group/index.tsx","../../src/modules/elements/table/modules/cardbar/index.tsx","../../src/modules/elements/table/modules/table-cardbar/index.tsx","../../src/modules/elements/table/modules/table-cell/index.tsx","../../src/modules/elements/table/index.tsx","../../src/modules/template-element/index.tsx","../../src/modules/template-leaf/index.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/modules/popup/content/index.tsx","../../src/modules/popup/index.tsx","../../src/modules/popups/image/index.tsx","../../src/modules/popups/color/index.tsx","../../src/modules/field/index.tsx","../../src/modules/popups/condition/index.tsx","../../src/modules/segmented-control/index.tsx","../../src/modules/popups/editable/copy-existing/index.tsx","../../src/modules/switch/index.tsx","../../src/modules/popups/editable/create-new/index.tsx","../../src/modules/popups/editable/index.tsx","../../src/modules/popups/image-size/index.tsx","../../src/modules/popups/orphan-nodes/index.tsx","../../src/modules/popups/text-size/index.tsx","../../src/modules/toolbar/index.tsx","../../src/core/plugins/paste-html.ts","../../src/core/plugins/table.ts","../../src/index.tsx","../../src/core/plugins/editable.ts","App.tsx","index.tsx"],"names":["LIST_TYPES","HOT_KEYS","PRESET_COLORS","ALIGNMENTS","EDITABLE_DATA_TYPES","text","options","radio","date","time","DATE_FORMATS","TIME_FORMATS","nil","value","notNil","clamp","min","max","Math","parseNumber","parsed","parseFloat","isNaN","formatDate","dateTime","token","format","Date","error","isHexColor","test","areEqualColors","left","right","generateUUID","uuidv4","isBlockActive","editor","match","Editor","SlateElement","n","isMarkActive","marks","nodesInSelection","getMatchingNodesInSelection","editableNodes","o","marksResolution","editablesResolution","includes","getColorMark","marksValue","editablesValue","toggleMarkActive","Transforms","hanging","toggleColorMarkActive","existingMark","color","toggleBlockActive","split","type","setBlockInactive","isList","newProperties","block","children","setBlockActive","focusEditor","ReactEditor","composeWithClassName","attributes","className","classnames","composeWithAlignmentClassName","alignment","composeWithStyle","style","getCurrentNode","selection","parentNode","getIndentation","currentNode","getIndentationPercent","composeWithEditable","editable","id","createEditableNode","isOrphan","editableNode","insertImageBlock","url","dimensions","width","height","label","imageNode","insertParagraph","at","insertTableBlock","columns","node","isCollapsed","Range","table","Array","createTableRow","borderless","data","getEditableAttributes","showTip","dataType","dateTimeFormat","multiline","defaultValue","tip","valueRef","parsedAttributes","getEditableAttributesValidity","copyExisting","getMatchingNodes","matching","generator","isInSameTable","start","end","startTable","endTable","startPath","endPath","Path","createTableContent","elements","createTableCell","colspan","rowspan","content","key","cellNodes","Button","memo","disabled","onPress","onClick","Header","title","createdAt","onChangeTitle","onPressSave","editorRef","useRef","state","innerRef","css","placeholder","html","current","onChange","event","onBlur","toCapitalizedFirst","formatRelative","OrphanNodesContext","createContext","TemplateEditor","ImageElement","element","selected","useSelected","focused","useFocused","useMemo","src","EditableElement","useEffect","fontSize","contentEditable","splittedTable","startKey","tableDepth","cells","cell","path","realPath","gridTable","insertPosition","i","y","x","j","k","_y","_x","isReal","originPath","getCol","result","row","removeSelection","defaultWidth","defaultHeight","tableStyle","borderSpacing","Layout","wordBreak","startFromX","HorizontalToolbar","tableNode","ref","useEditor","useState","cols","setCols","widthFnObject","colsArray","currCol","td","el","dataset","leftSumWidth","p","c","item","maxWidth","onHandleDrag","useCallback","index","changedWidth","e","tableWidthAfterChanged","dragger","draggerWidth","savedChangedWidth","moreThanMinWidth","target","onHandleDragEnd","offsetWidth","newCols","draggable","onMouseDown","document","onDragEnd","startFromY","VerticalToolbar","rows","setRows","heightFnObject","rowsArray","currCell","changedHeight","minHeight","draggerHeight","savedChangedHeight","moreThanMinHeight","offsetHeight","newRows","TableBody","props","useSlate","resizeTable","setStartKey","startNode","ResizeToolbar","React","onDragStart","onMouseMove","endKey","endNode","head","tail","tailPath","headPath","coverCols","col","selectedCell","addSelection","onMouseUp","onMouseLeave","splitCell","yIndex","xIndex","startCell","endCell","yStart","yEnd","xStart","xEnd","sourceCells","selectedCols","sourceCell","s","filterColsObject","Object","newPath","newCell","insertAbove","insertPositionCol","checkInsertEnable","insertYIndex","insertCols","originCol","newRow","insertBelow","insertLeft","checkInsertable","insertRight","mergeSelection","startPoint","selectedTable","selectedCount","currRow","t","selectedWidth","couldMerge","checkMerge","tmpContent","length","minRowHeight","mergedGridTable","idx","allColumnIsReal","minColWidth","insertContents","removeColumn","startCol","endCol","xLeft","xRight","topLeftCol","bottomRight","anchor","focus","removedCells","removedGridTable","removeRow","yTop","yBottom","removeCols","removeTable","toggleBorders","usePopupUtils","initialOpen","visible","setVisible","handleOpen","handleClose","handleToggle","open","close","toggle","useAlignmentValue","getAlignment","useMouseDown","fn","useOrphanNodes","useContext","Icon","handlePress","cloneElement","child","IconButton","forwardRef","active","IconGroup","exec","func","args","Cardbar","TableCardbar","run","action","delete","TableCell","dataKey","colSpan","rowSpan","position","minWidth","Table","existSelectedCell","onDrag","TemplateElement","indentation","paddingLeft","href","TemplateLeaf","leaf","Symbol","iterator","asyncIterator","Content","onLayoutUpdate","hideArrow","setDimensions","useLayoutEffect","computedDimensions","JSON","composedClassName","top","getViewportWidth","window","getViewportHeight","getPositioningWithoutAnchor","viewportWidth","viewportHeight","getValidPositioning","contentPosition","anchorElement","anchorRef","anchorWidth","anchorHeight","anchorX","anchorY","getPositioningWithAnchor","xOffset","offsets","yOffset","rightEdge","bottomEdge","Popup","contentClassName","transparent","distance","isVisible","overlayCloseOnClick","onRequestClose","popupContentPosition","setPopupContentPosition","handleClickOverlay","handleKeyUp","ImagePopup","onSubmitEditing","imageState","setImageState","scaleState","setScaleState","imageDimensions","setImageDimensions","decimalScale","handleChangeImageUrl","handleChangeScale","handleBlurImageInput","body","recover","then","Promise","img","resolve","naturalHeight","handleRequestClose","handlePressSubmit","maxLength","ColorBox","ColorPopup","onChangeColorOption","colorState","setColorState","handlePressColorOption","selectedColor","handleChangeInput","inputValue","parsedColor","Field","ConditionPopup","orphanNodes","parent","setParent","setValue","isValid","handleChangeParent","handleChangeValue","hidden","SegmentedControl","onChangeValue","handlePressOption","EditableCopyExisting","onSubmit","setValueRef","setDefaultValue","handleChangeValueRef","handleChangeDefaultValue","Switch","checked","offColor","onColor","checkedIcon","uncheckedIcon","handleDiameter","activeBoxShadow","EditableCreateNew","now","dataTypeOptions","dateFormatOptions","timeFormatOptions","setDataType","setDateTimeFormat","setLabel","setMultiline","setOptions","editingOption","setEditingOption","setShowTip","setIsOrphan","setTip","handlePressDeleteOption","eventualValue","handlePressAddOption","handleEditingOptionKeydown","handleChangeDataType","handleChangeDateTimeFormat","handleChangeEditingOption","handleChangeLabel","handleChangeTip","onKeyDown","EditablePopupProps","segment","setSegment","handleSubmit","ImageSizePopup","setWidth","setHeight","handleChangeWidth","handleChangeHeight","OrphanNodesPopup","setOrphanNodes","handlePressDelete","TextSizeOption","TextSizePopup","onPressOption","Toolbar","editorSelection","textSizePopupAnchorRef","colorPopupAnchorRef","imagePopupAnchorRef","imageSizePopupAnchorRef","conditionPopupAnchorRef","orphanNodesPopupAnchorRef","textSizePopup","colorPopup","imagePopup","imageSizePopup","editablePopup","conditionPopup","orphanNodesPopup","textSizeValue","headingOneActive","headingTwoActive","headingThreeActive","name","useTextSizeValue","leafColorValue","alignmentValue","canUndo","useCanUndo","canRedo","useCanRedo","conditionActive","handleChangeTextSizeOption","prevValue","handleChangeColorOption","handleCreateImage","handleCreateEditableImage","handleCreateEditable","insertEditableBlock","handleSetConditionActive","condition","setConditionActive","handlePressTextSize","handlePressColor","handlePressImage","handlePressEditableImage","handlePressInsertEditable","handlePressInsertTable","handlePressCondition","unsetConditionActive","handlePressInlineFormat","handlePressAlignment","setAlignment","handlePressIncreaseIndentation","increaseIndentation","handlePressDecreaseIndentation","decreaseIndentation","handlePressNumberedList","handlePressBulletedList","handlePressUndo","HistoryEditor","handlePressRedo","backgroundColor","ELEMENT_TAGS","A","BLOCKQUOTE","H1","H2","H3","H4","H5","H6","IMG","LI","OL","P","PRE","UL","TABLE","TH","TR","TD","TEXT_TAGS","CODE","code","DEL","strikethrough","EM","italic","I","S","STRONG","bold","U","underline","withHTML","insertData","isInline","isVoid","fragment","deserializeHTML","sanitized","nodeName","jsx","attrs","DOMParser","parseFromString","fragmentWithOnlyBlocks","inlineNodes","newFragments","maybePushInlineNodeParagraph","Text","wrapTopLevelInlineNodesInParagraphs","PreserveSpaceAfter","Set","PreserveSpaceBefore","withSchema","normalizeNode","entry","preserved","next","prev","shouldPreserveSpace","addMark","removeMark","deleteBackward","deleteFragment","lastSelection","isTable","selectedCells","isInTable","isStart","withTable","DocmakerEditor","initialValue","onSubmitChanges","initialData","withEditable","withReact","withHistory","createEditor","toDate","setTitle","editorState","setEditorState","renderElement","renderLeaf","handleEditorKeydown","isHotkey","hotkey","handlePressSave","nodes","orphans","spellCheck","App","console","log","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.859a910a.chunk.js","sourcesContent":["export const LIST_TYPES = ['numbered-list', 'bulleted-list']\n\nexport const HOT_KEYS = {\n  'mod+b': 'bold',\n  'mod+i': 'italic',\n  'mod+u': 'underline',\n  'mod+shift+x': 'strikethrough'\n}\n\nexport const PRESET_COLORS = [\n  '#FF6900',\n  '#FCB900',\n  '#7BDCB5',\n  '#00D084',\n  '#8ED1FC',\n  '#326FF3',\n  '#ABB8C3',\n  '#EB144C',\n  '#F78DA7',\n  '#9900EF'\n]\n\nexport const ALIGNMENTS = {\n  left: 'left',\n  right: 'right',\n  center: 'center',\n  justify: 'justify'\n}\n\nexport const INDENTATION_FACTOR = 3\n\nexport const EDITABLE_DATA_TYPES = {\n  text: 'Text',\n  options: 'Dropdown',\n  radio: 'Radio',\n  date: 'Date',\n  time: 'Time'\n}\n\nexport const DATE_FORMATS = [\n  'do MMMM, yyyy',\n  'dd MMMM, yyyy',\n  'MMMM dd, yyyy',\n  'dd/MM/yyyy',\n  'MM/dd/yyyy',\n  'MMM d, yyyy',\n  'dd MMM, yy',\n  'dd-MM-yyyy',\n  'dd-MM-yy'\n]\n\nexport const TIME_FORMATS = ['hh:mm a', 'hh:mm aaaa', 'HH:mm']\n","import format from 'date-fns/format'\nimport formatRelative from 'date-fns/formatRelative'\nimport { v4 as uuidv4 } from 'uuid'\n\nexport type ValidDate = Date | string | number\n\nexport type ImageDimensions = {\n  width: number\n  height: number\n}\n\n// ----------------------------------------------------------------\n// UTILITY\n// ----------------------------------------------------------------\n\nexport function nil<T>(value: T): boolean {\n  return typeof value === 'undefined' || value === null\n}\n\nexport function notNil<T>(value: T): boolean {\n  return !nil(value)\n}\n\nexport function getImageSizeAsync(url: string): Promise<ImageDimensions> {\n  if (!url) {\n    return null\n  }\n\n  return new Promise((resolve) => {\n    const img = document.createElement('img')\n\n    img.onload = () => {\n      resolve({ width: img.naturalWidth, height: img.naturalHeight })\n    }\n\n    img.onerror = () => {\n      resolve(null)\n    }\n\n    img.src = url\n  })\n}\n\n// ----------------------------------------------------------------\n// NUMBER\n// ----------------------------------------------------------------\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\nexport function parseNumber(value: string): number {\n  if (nil(value)) {\n    return null\n  }\n\n  const parsed = parseFloat(value)\n  return isNaN(parsed) ? 0 : parsed\n}\n\n// ----------------------------------------------------------------\n// DATETIME\n// ----------------------------------------------------------------\n\nexport function fromNow(dateTime: ValidDate): string {\n  return formatRelative(new Date(dateTime), new Date())\n}\n\nexport function formatDate(dateTime: ValidDate, token = 'yyyy-MM-dd'): string {\n  if (nil(dateTime)) return undefined\n\n  try {\n    return format(\n      dateTime instanceof Date ? dateTime : new Date(dateTime),\n      token\n    )\n  } catch (error) {\n    return undefined\n  }\n}\n\nexport function toDate(dateTime: ValidDate): Date {\n  if (!dateTime) {\n    return new Date()\n  }\n\n  return dateTime instanceof Date ? dateTime : new Date(dateTime)\n}\n\n// ----------------------------------------------------------------\n// STRING\n// ----------------------------------------------------------------\n\nexport function toTitleCase(text: string) {\n  if (nil(text)) {\n    return text\n  }\n  return `${text[0]?.toUpperCase()}${text?.substr(1).toLowerCase()}`\n}\n\nexport function toCapitalizedFirst(text: string) {\n  if (nil(text)) {\n    return text\n  }\n  return `${text[0]?.toUpperCase()}${text?.substr(1)}`\n}\n\nexport function stripHTMLEntities(text: string) {\n  return text\n    ?.replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/\"/g, '&nbsp;')\n}\n\nexport function isHexColor(text: string) {\n  return /^#([0-9A-F]{3}){1,2}$/i.test(text)\n}\n\nexport function areEqualColors(left: string, right: string) {\n  left = left?.replace(/^#/gi, '')?.toLowerCase()\n  right = right?.replace(/^#/gi, '')?.toLowerCase()\n\n  return left === right\n}\n\nexport function getPlaceholderImage(width: number, height?: number) {\n  return `https://dummyimage.com/${width}x${height || width}/326FF3/FFFFFF`\n}\n\nexport function generateUUID() {\n  return uuidv4()\n}\n","import {\n  Editor,\n  Node,\n  NodeEntry,\n  Path,\n  Point,\n  Range,\n  Element as SlateElement,\n  Transforms\n} from 'slate'\nimport { INDENTATION_FACTOR, LIST_TYPES } from '../constants'\nimport { areEqualColors, clamp, generateUUID, nil, notNil } from '../utils'\n\nimport { CSSProperties } from 'react'\nimport { HistoryEditor } from 'slate-history'\nimport { ImageElementType } from '../../modules/elements/image'\nimport { ImageProps } from '../../modules/popups/image'\nimport { ReactEditor } from 'slate-react'\nimport classnames from 'classnames'\n\nexport type TableCell = {\n  type: 'table-cell'\n  key: string\n  rowspan?: number\n  colspan?: number\n  width?: number\n  height?: number\n  selectedCell?: boolean\n  children: Node[]\n} & SlateElement\n\nexport type TableRow = {\n  type: 'table-row'\n  key: string\n  data: any\n  children: TableCell[]\n} & SlateElement\n\nexport type TableContent = {\n  type: 'table-content'\n  children: Node[]\n} & SlateElement\n\nexport type Table = {\n  type: 'table'\n  children: TableRow[]\n  data: any\n  borderless?: boolean\n} & SlateElement\n\nexport type BlockAlignment = 'left' | 'center' | 'right' | 'justify'\n\nexport type LeafFormatType =\n  | 'bold'\n  | 'code'\n  | 'italic'\n  | 'underline'\n  | 'strikethrough'\n  | 'color'\n  | 'ref'\n\nexport type HeadingFormatType = 'heading-one' | 'heading-two' | 'heading-three'\n\nexport type ListFormatType = 'numbered-list' | 'bulleted-list'\n\nexport type QuoteFormatType = 'block-quote'\n\nexport type TableFormatType =\n  | 'table'\n  | 'table-content'\n  | 'table-row'\n  | 'table-cell'\n\nexport type ElementFormatType =\n  | HeadingFormatType\n  | ListFormatType\n  | QuoteFormatType\n  | TableFormatType\n\nexport type SlateEditorType = Editor & ReactEditor & HistoryEditor\n\nexport type EditableElementType<T> = {\n  id?: string\n  editable?: true\n} & T\n\nexport type EditableDataType =\n  | 'text'\n  | 'options'\n  | 'radio'\n  | 'time'\n  | 'date'\n  | 'image'\n\nexport type EditableOption = {\n  id: string\n  label: string\n}\n\nexport type EditableRefAttributes = {\n  parent: string\n  value: string\n}\n\nexport type EditableAttributes = Partial<{\n  dataType: EditableDataType\n  dateTimeFormat: string\n  defaultValue: string\n  label: string\n  multiline: boolean\n  options: Array<EditableOption>\n  tip: string\n  valueRef: string\n  ref: EditableRefAttributes\n  isOrphan: boolean\n  children: Array<EditableAttributes & { text: string }>\n}>\n\nexport type DocmakerNode = EditableElementType<\n  EditableAttributes & { text: string }\n>\n\nexport type DocmakerData = Partial<{\n  title: string\n  createdAt: string\n  nodes: Array<DocmakerNode>\n  orphans: Array<DocmakerNode>\n}>\n\nexport function isBlockActive(\n  editor: SlateEditorType,\n  format: ElementFormatType\n) {\n  const [match] = Editor.nodes(editor, {\n    match: (n) =>\n      !Editor.isEditor(n) && SlateElement.isElement(n) && n.type === format\n  }) as any\n\n  return !!match\n}\n\nexport function isMarkActiveLegacy(\n  editor: SlateEditorType,\n  format: LeafFormatType\n) {\n  if (!editor) {\n    return null\n  }\n\n  const marks = Editor.marks(editor)\n\n  if (notNil(marks)) {\n    const value = marks[format]\n    return format === 'ref' ? notNil(value) : value === true\n  }\n\n  return false\n}\n\nexport function isMarkActive(editor: SlateEditorType, format: LeafFormatType) {\n  if (!editor) {\n    return null\n  }\n\n  const marks = Editor.marks(editor)\n  const nodesInSelection = getMatchingNodesInSelection(editor, (o) =>\n    Editor.isInline(editor, o)\n  )\n  const editableNodes = getMatchingNodesInSelection(\n    editor,\n    (o) => o.type === 'editable'\n  )\n\n  let marksResolution = false\n  let editablesResolution = false\n\n  if (notNil(marks)) {\n    const value = marks[format]\n    marksResolution = ['color', 'ref'].includes(format)\n      ? notNil(value)\n      : value === true\n  }\n\n  if (editableNodes?.length) {\n    editablesResolution = editableNodes\n      .map((o) =>\n        ['color', 'ref'].includes(format)\n          ? notNil(o[format])\n          : o[format] === true\n      )\n      .every((o) => o)\n  }\n\n  if (\n    nodesInSelection?.length &&\n    nodesInSelection.every((o) => editableNodes.includes(o))\n  ) {\n    return editablesResolution\n  }\n\n  return editableNodes?.length\n    ? editablesResolution && marksResolution\n    : marksResolution\n}\n\nexport function isColorMarkActive(editor: SlateEditorType) {\n  if (!editor) {\n    return null\n  }\n\n  const marks = Editor.marks(editor)\n  return marks ? notNil(marks.color) : false\n}\n\nexport function getColorMark(editor: SlateEditorType) {\n  if (!editor) {\n    return null\n  }\n\n  const marks = Editor.marks(editor)\n  const nodesInSelection = getMatchingNodesInSelection(editor, (o) =>\n    Editor.isInline(editor, o)\n  )\n  const editableNodes = getMatchingNodesInSelection(\n    editor,\n    (o) => o.type === 'editable'\n  )\n\n  const marksValue = marks?.color\n  let editablesValue = null\n\n  if (editableNodes?.length) {\n    editablesValue = editableNodes[0].color\n  }\n\n  if (\n    nodesInSelection?.length &&\n    nodesInSelection.every((o) => editableNodes.includes(o))\n  ) {\n    return editablesValue\n  }\n\n  return editableNodes?.length ? editablesValue : marksValue\n}\n\nexport function toggleMarkActiveLegacy(\n  editor: SlateEditorType,\n  format: LeafFormatType\n) {\n  const isActive = isMarkActive(editor, format)\n\n  if (isActive) {\n    Editor.removeMark(editor, format)\n  } else {\n    Editor.addMark(editor, format, true)\n  }\n}\n\nexport function toggleMarkActive(\n  editor: SlateEditorType,\n  format: LeafFormatType\n) {\n  const isActive = isMarkActive(editor, format)\n\n  if (isActive) {\n    Editor.removeMark(editor, format)\n    Transforms.unsetNodes(editor, format, {\n      match: (o) => Editor.isVoid(editor, o) && o.type === 'editable'\n    })\n  } else {\n    Transforms.setNodes(\n      editor,\n      { [format]: true },\n      {\n        match: (o) => Editor.isVoid(editor, o) && o.type === 'editable',\n        hanging: true\n      }\n    )\n    Editor.addMark(editor, format, true)\n  }\n}\n\nexport function toggleColorMarkActive(editor: SlateEditorType, value?: string) {\n  const existingMark = getColorMark(editor)\n\n  if (notNil(existingMark) && areEqualColors(existingMark, value)) {\n    Editor.removeMark(editor, 'color')\n    Transforms.unsetNodes(editor, 'color', {\n      match: (o) => Editor.isVoid(editor, o) && o.type === 'editable'\n    })\n  } else {\n    Transforms.setNodes(\n      editor,\n      { color: value },\n      {\n        match: (o) => Editor.isVoid(editor, o) && o.type === 'editable',\n        hanging: true\n      }\n    )\n    Editor.addMark(editor, 'color', value)\n  }\n}\n\nexport function toggleBlockActive(\n  editor: SlateEditorType,\n  format: ElementFormatType\n) {\n  const isActive = isBlockActive(editor, format)\n\n  if (isActive) {\n    setBlockInactive(editor)\n    return\n  }\n\n  setBlockActive(editor, format)\n}\n\nexport function setBlockActive(\n  editor: SlateEditorType,\n  format: ElementFormatType\n) {\n  const isList = LIST_TYPES.includes(format)\n\n  Transforms.unwrapNodes(editor, {\n    match: (n) =>\n      LIST_TYPES.includes(\n        !Editor.isEditor(n) && SlateElement.isElement(n) && (n.type as any)\n      ),\n    split: true\n  })\n\n  const newProperties: Partial<SlateElement> = {\n    type: isList ? 'list-item' : format\n  }\n\n  Transforms.setNodes(editor, newProperties)\n\n  if (isList) {\n    const block = { type: format, children: [] }\n    Transforms.wrapNodes(editor, block)\n  }\n}\n\nexport function setBlockInactive(editor: SlateEditorType) {\n  Transforms.unwrapNodes(editor, {\n    match: (n) =>\n      LIST_TYPES.includes(\n        !Editor.isEditor(n) && SlateElement.isElement(n) && (n.type as any)\n      ),\n    split: true\n  })\n\n  const newProperties: Partial<SlateElement> = {\n    type: 'paragraph'\n  }\n\n  Transforms.setNodes(editor, newProperties)\n}\n\nexport function focusEditor(editor: SlateEditorType) {\n  ReactEditor.focus(editor as ReactEditor)\n}\n\nexport function composeWithClassName(attributes: any, className?: string) {\n  return {\n    ...attributes,\n    className: classnames(attributes?.className, className)\n  }\n}\n\nexport function composeWithAlignmentClassName(\n  attributes: any,\n  alignment?: BlockAlignment,\n  className?: string\n) {\n  return {\n    ...attributes,\n    className: classnames(attributes?.className, className, {\n      'text-right': alignment === 'right',\n      'text-center': alignment === 'center',\n      'text-justify': alignment === 'justify'\n    })\n  }\n}\n\nexport function composeWithStyle(attributes: any, style: CSSProperties = {}) {\n  return {\n    ...attributes,\n    style: { ...(attributes?.style || {}), ...style }\n  }\n}\n\nexport function getCurrentNode(editor: SlateEditorType) {\n  const selection = editor?.selection\n\n  if (selection !== null && selection.anchor !== null) {\n    const parentNode = editor.children[selection.anchor.path[0]]\n\n    if (LIST_TYPES.includes(parentNode?.type as BlockAlignment)) {\n      return parentNode.children[selection.anchor.path[1]]\n    }\n\n    return parentNode\n  } else {\n    return null\n  }\n}\n\nexport function getAlignment(editor: SlateEditorType): BlockAlignment {\n  const currentNode = getCurrentNode(editor) as any\n  return currentNode?.alignment\n}\n\nexport function setAlignment(editor: SlateEditorType, value?: BlockAlignment) {\n  const alignment = value === 'left' ? null : value\n  const newProperties: Partial<SlateElement> = {\n    alignment\n  }\n\n  Transforms.setNodes(editor, newProperties)\n}\n\nexport function getIndentation(editor: SlateEditorType): number {\n  const currentNode = getCurrentNode(editor) as any\n  return currentNode?.indentation\n}\n\nexport function getIndentationPercent(value: number): string {\n  if (!value) {\n    return null\n  }\n\n  return `${value}%`\n}\n\nexport function increaseIndentation(editor: SlateEditorType) {\n  const currentIndentation = getIndentation(editor) || 0\n  const indentation = clamp(currentIndentation + INDENTATION_FACTOR, 0, 99)\n  const newProperties: Partial<SlateElement> = {\n    indentation\n  }\n\n  Transforms.setNodes(editor, newProperties)\n}\n\nexport function decreaseIndentation(editor: SlateEditorType) {\n  const currentIndentation = getIndentation(editor) || 0\n  const indentation = clamp(currentIndentation - INDENTATION_FACTOR, 0, 99)\n  const newProperties: Partial<SlateElement> = {\n    indentation: indentation === 0 ? null : indentation\n  }\n\n  Transforms.setNodes(editor, newProperties)\n}\n\nexport function composeWithEditable<T extends object>(\n  attributes: T\n): EditableElementType<T> {\n  if (nil(attributes)) {\n    return null\n  }\n\n  return {\n    ...attributes,\n    editable: true,\n    id: generateUUID()\n  }\n}\n\nexport function createEditableNode(\n  attributes: EditableAttributes,\n  isOrphan = false\n) {\n  let editableNode: SlateElement & EditableAttributes = {\n    type: 'editable',\n    ...attributes,\n    children: [{ text: '' }]\n  }\n\n  if (isOrphan) {\n    editableNode.isOrphan = isOrphan\n  }\n\n  editableNode = composeWithEditable(editableNode)\n\n  return editableNode\n}\n\nexport function insertImageBlock(\n  editor: SlateEditorType,\n  attributes: ImageProps,\n  editable?: boolean\n) {\n  const {\n    url,\n    dimensions: { width, height },\n    label\n  } = attributes\n\n  let imageNode: SlateElement & ImageElementType = {\n    type: 'image',\n    url,\n    width,\n    height,\n    children: [{ text: '' }]\n  }\n\n  if (editable) {\n    imageNode.type = 'editable'\n    imageNode.dataType = 'image'\n    imageNode.label = label\n    imageNode = composeWithEditable(imageNode)\n  }\n\n  Transforms.insertNodes(editor, imageNode)\n  Transforms.move(editor)\n}\n\nexport function insertEditableBlock(\n  editor: SlateEditorType,\n  attributes: EditableAttributes\n) {\n  const editableNode = createEditableNode(attributes)\n\n  Transforms.insertNodes(editor, editableNode)\n  Transforms.move(editor)\n}\n\nexport function insertParagraph(\n  editor: Editor & ReactEditor,\n  at: Path | Point,\n  text = ''\n) {\n  Transforms.insertNodes(\n    editor,\n    {\n      type: 'paragraph',\n      children: [{ text }]\n    },\n    {\n      at\n    }\n  )\n}\n\nexport function insertTableBlock(editor: SlateEditorType) {\n  if (!editor.selection) return\n\n  const node = Editor.above(editor, {\n    match: (n) => n.type === 'table'\n  })\n\n  const isCollapsed = Range.isCollapsed(editor.selection)\n\n  if (!node && isCollapsed) {\n    const table = createTable(3, 3)\n    Transforms.insertNodes(editor, table)\n  }\n}\n\nexport function getEditableAttributes(\n  attributes: EditableAttributes,\n  showTip = false\n) {\n  const {\n    dataType,\n    dateTimeFormat,\n    multiline,\n    defaultValue,\n    label,\n    options,\n    tip,\n    valueRef\n  } = attributes\n\n  const parsedAttributes = {\n    dataType,\n    defaultValue\n  } as EditableAttributes\n\n  if (valueRef?.length) {\n    parsedAttributes.valueRef = valueRef\n    return parsedAttributes\n  }\n\n  if (showTip) {\n    parsedAttributes.tip = tip\n  }\n\n  if (dataType === 'text' && multiline) {\n    parsedAttributes.multiline = multiline\n  }\n\n  if (['options', 'radio'].includes(dataType)) {\n    parsedAttributes.options = options\n  }\n\n  if (['date', 'time'].includes(dataType)) {\n    parsedAttributes.dateTimeFormat = dateTimeFormat\n  }\n\n  parsedAttributes.label = label\n\n  return parsedAttributes\n}\n\nexport function getEditableAttributesValidity(\n  attributes: EditableAttributes,\n  showTip = false,\n  copyExisting = false\n): boolean {\n  const {\n    dataType,\n    dateTimeFormat,\n    defaultValue,\n    label,\n    options,\n    tip,\n    valueRef\n  } = attributes\n\n  if (copyExisting) {\n    return !!valueRef?.length && !!defaultValue?.length\n  }\n\n  if (\n    !dataType?.length ||\n    !defaultValue?.length ||\n    !label?.length ||\n    (showTip && !tip.length)\n  ) {\n    return false\n  }\n\n  if (['options', 'radio'].includes(dataType)) {\n    return !!options?.length\n  }\n\n  if (['date', 'time'].includes(dataType)) {\n    return !!dateTimeFormat?.length\n  }\n\n  return true\n}\n\nexport function getMatchingNodes(\n  node: Node,\n  match: (node: Node) => boolean = () => true,\n  matching: Array<Node> = []\n) {\n  if (match(node)) {\n    matching.push(node)\n  }\n\n  const children = node.children as Array<Node>\n\n  if (children?.length) {\n    for (const child of children) {\n      getMatchingNodes(child, match, matching)\n    }\n  }\n\n  return matching\n}\n\nexport function getMatchingNodesInSelection(\n  node: SlateEditorType,\n  match: (node: Node) => boolean = () => true\n) {\n  const generator = Editor.nodes(node, {\n    match\n  })\n\n  return Array.from(generator).map((o) => o[0])\n}\n\nexport function setConditionActive(\n  editor: SlateEditorType,\n  condition: EditableRefAttributes\n) {\n  Editor.addMark(editor, 'ref', condition)\n  Transforms.setNodes(\n    editor,\n    { ref: condition },\n    {\n      match: (o) => Editor.isVoid(editor, o) && o.type === 'editable'\n    }\n  )\n}\n\nexport function unsetConditionActive(editor: SlateEditorType) {\n  Editor.removeMark(editor, 'ref')\n  Transforms.unsetNodes(editor, 'ref', {\n    match: (o) => Editor.isVoid(editor, o) && o.type === 'editable'\n  })\n}\n\nexport function checkTableIsExist(editor: Editor, table: NodeEntry) {\n  const cells = Array.from(\n    Editor.nodes(editor, {\n      at: table[1],\n      match: (n) => n.type === 'table-cell'\n    })\n  )\n\n  return !!cells.length\n}\n\nexport function isTableElement(type: string) {\n  return (\n    type === 'table' ||\n    type === 'table-row' ||\n    type === 'table-cell' ||\n    type === 'table-content'\n  )\n}\n\nexport function isInSameTable(editor: Editor): boolean {\n  if (!editor.selection) return false\n\n  const [start, end] = Editor.edges(editor, editor.selection)\n  const [startTable] = Editor.nodes(editor, {\n    at: start,\n    match: (n) => n.type === 'table'\n  })\n\n  const [endTable] = Editor.nodes(editor, {\n    at: end,\n    match: (n) => n.type === 'table'\n  })\n\n  if (startTable && endTable) {\n    const [, startPath]: [any, Path] = startTable\n    const [, endPath]: [any, Path] = endTable\n\n    if (Path.equals(startPath, endPath)) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport function createTableContent(elements?: Node[]): TableContent {\n  return {\n    type: 'table-content',\n    children: elements || [{ type: 'paragraph', children: [{ text: '' }] }]\n  }\n}\n\nexport function createTableCell({\n  elements,\n  colspan,\n  rowspan,\n  height,\n  width\n}: {\n  elements?: Node[]\n  height?: number\n  width?: number\n  colspan?: number\n  rowspan?: number\n} = {}): TableCell {\n  const content = createTableContent(elements)\n\n  return {\n    type: 'table-cell',\n    key: `cell_${generateUUID()}`,\n    children: [content],\n    width: width,\n    height: height,\n    colspan,\n    rowspan\n  }\n}\n\nexport function createTableRow(columns: number): TableRow {\n  const cellNodes = [...new Array(columns)].map(() => createTableCell())\n\n  return {\n    type: 'table-row',\n    key: `row_${generateUUID()}`,\n    data: {},\n    children: cellNodes\n  }\n}\n\nexport function createTable(columns: number, rows: number): Table {\n  const rowNodes = [...new Array(rows)].map(() => createTableRow(columns))\n\n  return {\n    type: 'table',\n    children: rowNodes,\n    borderless: false,\n    data: {}\n  }\n}\n","import React, { FC, memo, PropsWithChildren } from 'react'\nimport classnames from 'classnames'\n\ntype ButtonProps = PropsWithChildren<{\n  className?: string\n  disabled?: boolean\n  onPress?: Fn\n}>\n\nconst BaseButton: FC<ButtonProps> = ({\n  children,\n  className,\n  disabled,\n  onPress\n}) => {\n  return (\n    <button\n      onClick={onPress}\n      className={classnames(\n        'border-transparent rounded-default font-medium cursor-pointer text-white px-18 flex items-center justify-center transition-colors duration-250 hover:bg-blue-600',\n        {\n          'bg-blue-500': !disabled,\n          'pointer-events-none bg-blue-300': disabled,\n          'h-40': !/\\bh-[0-9]/gi.test(className)\n        },\n        className\n      )}\n    >\n      {children}\n    </button>\n  )\n}\n\nconst Button = memo(BaseButton)\n\nexport default Button\n","import React, { FC, useRef } from 'react'\nimport ContentEditable, { ContentEditableEvent } from 'react-contenteditable'\nimport Button from '../button'\nimport classnames from 'classnames'\nimport css from './style.module.css'\nimport { fromNow, toCapitalizedFirst } from '../../core/utils'\n\ntype HeaderProps = {\n  title?: string\n  createdAt?: string\n  onChangeTitle?: (value: string) => void\n  onPressSave?: Fn\n}\n\nconst Header: FC<HeaderProps> = ({\n  title,\n  createdAt,\n  onChangeTitle,\n  onPressSave\n}) => {\n  const editorRef = useRef(null)\n  const state = useRef(title)\n\n  const handleBlur = () => {\n    onChangeTitle?.(state.current)\n  }\n\n  const handleChange = (event: ContentEditableEvent) => {\n    const value = event.target.value\n    state.current = value\n\n    if (value === '<br>') {\n      editorRef.current.innerHTML = ''\n    }\n  }\n\n  return (\n    <div className='bg-white py-18 px-60 flex items-center justify-between'>\n      <div>\n        <ContentEditable\n          innerRef={editorRef}\n          className={classnames(\n            css.container,\n            'text-heading-2 font-medium mb-4'\n          )}\n          placeholder='Untitled document'\n          html={state.current}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {createdAt && (\n          <div className='font-medium text-gray-400 text-subhead'>\n            {toCapitalizedFirst(fromNow(createdAt))}\n          </div>\n        )}\n      </div>\n      <Button disabled={!state.current?.length} onPress={onPressSave}>\n        Save changes\n      </Button>\n    </div>\n  )\n}\n\nexport default Header\n","import { createContext, Dispatch, SetStateAction } from 'react'\nimport { Node } from 'slate'\n\nconst OrphanNodesContext = createContext<\n  [Array<Node>, Dispatch<SetStateAction<Array<Node>>>]\n>(null)\n\nexport default OrphanNodesContext\n","import React, { FC } from 'react'\n\ntype TemplateEditorProps = {}\n\nconst TemplateEditor: FC<TemplateEditorProps> = ({ children }) => {\n  return <div className='max-w-6xl m-auto pt-120 pb-120 px-60'>{children}</div>\n}\n\nexport default TemplateEditor\n","import React, { FC, PropsWithChildren, useMemo } from 'react'\nimport { useFocused, useSelected } from 'slate-react'\n\nimport { EditableElementType } from '../../../core/tools'\nimport classnames from 'classnames'\nimport { getPlaceholderImage } from '../../../core/utils'\n\nexport type ImageElementType = EditableElementType<{\n  url: string\n  label?: string\n  width?: number\n  height?: number\n}>\n\ntype ImageElementProps = PropsWithChildren<{\n  attributes: any\n  element: ImageElementType\n}>\n\nconst ImageElement: FC<ImageElementProps> = ({\n  attributes,\n  children,\n  element\n}) => {\n  const selected = useSelected()\n  const focused = useFocused()\n  const url = useMemo(\n    () =>\n      element.editable\n        ? getPlaceholderImage(element.width, element.height)\n        : element.url,\n    [element.editable, element.height, element.url, element.width]\n  )\n\n  return (\n    <span {...attributes}>\n      {children}\n      <img\n        src={url}\n        style={{ width: element.width, height: element.height }}\n        className={classnames(\n          'inline-block max-w-full rounded-default align-bottom',\n          {\n            'shadow-outline': selected && focused\n          }\n        )}\n      />\n    </span>\n  )\n}\n\nexport default ImageElement\n","import React, { FC, PropsWithChildren, useEffect } from 'react'\nimport { useFocused, useSelected } from 'slate-react'\nimport classnames from 'classnames'\nimport {\n  composeWithClassName,\n  composeWithStyle,\n  EditableAttributes,\n  EditableElementType\n} from '../../../core/tools'\n\ntype EditableElementProps = PropsWithChildren<{\n  attributes: any\n  element: EditableElementType<EditableAttributes>\n}>\n\nconst EditableElement: FC<EditableElementProps> = ({\n  attributes,\n  children,\n  element\n}) => {\n  const selected = useSelected()\n  const focused = useFocused()\n\n  useEffect(() => {\n    return () => {\n      // TODO: Find refs that match unset ref value\n    }\n  }, [])\n\n  return (\n    <span\n      {...composeWithStyle(\n        composeWithClassName(\n          attributes,\n          classnames(\n            'bg-blue-500 text-white font-medium px-4 py-2 rounded-default mx-1',\n            {\n              'shadow-outline': selected && focused\n            }\n          )\n        ),\n        { fontSize: '0.82em' }\n      )}\n      contentEditable={false}\n    >\n      {element.defaultValue}\n      {children}\n    </span>\n  )\n}\n\nexport default EditableElement\n","import { Editor, NodeEntry, Path, Transforms } from 'slate'\n\nimport { TableCell } from '../../../../core/tools'\n\nexport type Col = {\n  cell: TableCell\n  isReal: boolean\n  path: Path\n  originPath: Path\n  isInsertPosition?: boolean\n}\n\nexport const splittedTable: (\n  editor: Editor,\n  table: NodeEntry,\n  startKey?: string | undefined\n) => {\n  tableDepth?: number\n  gridTable: Col[][]\n  getCol: (match?: (node: Col) => boolean) => Col[]\n} = (editor, table, startKey) => {\n  const tableDepth = table[1].length\n\n  const cells = [] as { cell: TableCell; path: Path; realPath: Path }[]\n\n  const nodes = Editor.nodes(editor, {\n    at: table[1],\n    match: (n) => n.type === 'table-cell'\n  })\n\n  for (const node of nodes) {\n    const [cell, path] = node as [TableCell, Path]\n    cells.push({\n      cell,\n      path,\n      realPath: [...path]\n    })\n  }\n\n  const gridTable: Col[][] = []\n  let insertPosition = null\n\n  for (let i = 0; i < cells.length; i++) {\n    const { cell, path, realPath } = cells[i]\n    const { rowspan = 1, colspan = 1 } = cell\n    const y = path[tableDepth]\n    let x = path[tableDepth + 1]\n\n    if (!gridTable[y]) {\n      gridTable[y] = []\n    }\n\n    while (gridTable[y][x]) {\n      x++\n    }\n\n    for (let j = 0; j < rowspan; j++) {\n      for (let k = 0; k < colspan; k++) {\n        const _y = y + j\n        const _x = x + k\n\n        if (!gridTable[_y]) {\n          gridTable[_y] = []\n        }\n\n        gridTable[_y][_x] = {\n          cell,\n          path: [...realPath.slice(0, tableDepth), _y, _x],\n          isReal: (rowspan === 1 && colspan === 1) || (_y === y && _x === x),\n          originPath: path\n        }\n\n        if (!insertPosition && cell.key === startKey) {\n          insertPosition = gridTable[_y][_x]\n          gridTable[_y][_x].isInsertPosition = true\n        }\n      }\n    }\n  }\n\n  const getCol = (match?: (node: Col) => boolean): Col[] => {\n    const result: Col[] = []\n\n    gridTable.forEach((row) => {\n      row.forEach((col: Col) => {\n        if (match && match(col)) {\n          result.push(col)\n        }\n      })\n    })\n\n    return result\n  }\n\n  return {\n    gridTable,\n    tableDepth,\n    getCol\n  }\n}\n\nexport function addSelection(\n  editor: Editor,\n  table: NodeEntry | null,\n  startPath: Path,\n  endPath: Path\n): Col[] {\n  removeSelection(editor)\n\n  if (!table) return []\n\n  const { gridTable, getCol } = splittedTable(editor, table)\n\n  if (!getCol || !gridTable) return []\n\n  const [head] = getCol(\n    (n: Col) =>\n      Path.equals(Editor.path(editor, n.originPath), startPath) && n.isReal\n  )\n  const [tail] = getCol(\n    (n: Col) =>\n      Path.equals(Editor.path(editor, n.originPath), endPath) && n.isReal\n  )\n\n  if (!tail || !head) return []\n\n  const { path: tailPath } = tail\n  const { path: headPath } = head\n\n  headPath.forEach((item: number, index: number) => {\n    headPath[index] = Math.min(item, tailPath[index])\n    tailPath[index] = Math.max(item, tailPath[index])\n  })\n\n  const coverCols: Col[] = []\n\n  gridTable.forEach((row: Col[]) => {\n    row.forEach((col: Col) => {\n      const { path } = col\n\n      const isOver = path.findIndex((item, index) => {\n        if (item < headPath[index] || item > tailPath[index]) {\n          return true\n        }\n        return false\n      })\n\n      if (isOver < 0) {\n        coverCols.push(col)\n      }\n    })\n  })\n\n  coverCols.forEach(({ originPath }) => {\n    Transforms.setNodes(\n      editor,\n      {\n        selectedCell: true\n      },\n      {\n        at: originPath,\n        match: (n) => n.type === 'table-cell'\n      }\n    )\n  })\n\n  return coverCols\n}\n\nexport function removeSelection(editor: Editor) {\n  Transforms.unsetNodes(editor, 'selectedCell', {\n    at: [],\n    match: (n) => !!n.selectedCell\n  })\n}\n","import { CSSProperties } from 'react'\n\nexport const options = {\n  defaultWidth: 50 as number,\n  defaultHeight: 22 as number,\n  tableStyle: {\n    borderSpacing: 0,\n    Layout: 'fixed',\n    wordBreak: 'break-word'\n  } as CSSProperties\n}\n","import { NodeEntry, Transforms } from 'slate'\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'\n\nimport css from '../../style.module.css'\nimport { options } from '../../utils/options'\nimport { splittedTable } from '../../utils/selection'\nimport { useEditor } from 'slate-react'\n\nlet startFromX = 0\n\nexport const HorizontalToolbar: React.FC<{\n  table: HTMLElement\n  tableNode: NodeEntry\n}> = ({ table, tableNode }) => {\n  const ref = useRef<HTMLDivElement>(null)\n  const editor = useEditor()\n  const [cols, setCols] = useState<{ width: number; el: HTMLElement[] }[]>([])\n  const widthFnObject = useRef({}).current\n\n  useEffect(() => {\n    const { gridTable = [] } = splittedTable(editor, tableNode)\n    if (!gridTable.length) return\n\n    const colsArray = [] as { width: number; el: HTMLElement[] }[]\n    for (let i = 0; i < gridTable[0].length; i++) {\n      for (let j = 0; j < gridTable.length; j++) {\n        const currCol = gridTable[j][i]\n        if (!currCol) continue\n\n        const td = table.querySelector(\n          `[data-key=${currCol.cell.key}]`\n        ) as HTMLElement\n\n        if (!td) continue\n\n        if (!colsArray[i]) {\n          colsArray[i] = {\n            width: 0,\n            el: []\n          }\n        }\n\n        colsArray[i].width = !colsArray[i].width\n          ? td.offsetWidth + td.offsetLeft\n          : Math.min(colsArray[i].width, td.offsetWidth + td.offsetLeft)\n\n        if (\n          colsArray[i].el.findIndex(\n            ({ dataset }) => dataset.key === td.dataset.key\n          ) < 0\n        ) {\n          colsArray[i].el.push(td)\n        }\n      }\n    }\n\n    for (let i = 1; i < colsArray.length; i++) {\n      const leftSumWidth = colsArray\n        .slice(0, i)\n        .reduce((p, c) => p + c.width, 0)\n      colsArray[i].width = colsArray[i].width - leftSumWidth\n    }\n    setCols(colsArray.filter((item) => item.width))\n  }, [editor, table, tableNode])\n\n  const maxWidth = useMemo(() => table.closest('div')?.offsetWidth, [table])\n\n  const onHandleDrag = useCallback(\n    ({ item, index }) => {\n      if (widthFnObject[index]) {\n        return widthFnObject[index]\n      }\n\n      const fn = function (e: React.MouseEvent) {\n        const changedWidth = e.clientX - startFromX\n\n        if (!changedWidth || !e.clientX) {\n          return\n        }\n\n        const tableWidthAfterChanged = table.offsetWidth + changedWidth\n\n        if (item.el && maxWidth && tableWidthAfterChanged < maxWidth) {\n          const dragger = ref.current?.querySelector(\n            `#horizontal-dragger-item-${index}`\n          ) as HTMLElement\n\n          if (!dragger) return\n          const draggerWidth = dragger.offsetWidth\n\n          if (draggerWidth + changedWidth > options.defaultWidth) {\n            dragger.style.width = `${draggerWidth + changedWidth}px`\n          }\n\n          const savedChangedWidth = []\n          let moreThanMinWidth = true\n          for (const cell of item.el) {\n            if (cell.offsetWidth + changedWidth <= options.defaultWidth) {\n              moreThanMinWidth = false\n              break\n            }\n            savedChangedWidth.push({\n              target: cell,\n              width: cell.offsetWidth + changedWidth\n            })\n          }\n\n          if (moreThanMinWidth) {\n            savedChangedWidth.forEach((item) => {\n              item.target.style.width = `${item.width}px`\n            })\n          }\n        }\n\n        startFromX = e.clientX\n      }\n\n      widthFnObject[index] = fn\n      return widthFnObject[index]\n    },\n    [maxWidth, table, widthFnObject]\n  )\n\n  const onHandleDragEnd = useCallback(\n    (item: { width: number; el: HTMLElement[] }, index: number) => () => {\n      if (item.el) {\n        for (const cell of item.el) {\n          Transforms.setNodes(\n            editor,\n            {\n              width: cell.offsetWidth\n            },\n            {\n              at: tableNode[1],\n              match: (n) => n.key === cell.dataset.key\n            }\n          )\n        }\n\n        const dragger = ref.current?.querySelector(\n          `#horizontal-dragger-item-${index}`\n        ) as HTMLElement\n        const draggerWidth = dragger.offsetWidth\n\n        const newCols = Array.from(cols)\n        newCols[index] = {\n          width: draggerWidth,\n          el: item.el\n        }\n\n        setCols(() => newCols)\n      }\n    },\n    [cols, editor, tableNode]\n  )\n\n  return (\n    <div\n      contentEditable={false}\n      className={css['table-horizontal-toolbar']}\n      ref={ref}\n    >\n      {cols.map((item, index) => (\n        <div\n          key={index}\n          className={css['table-dragger-item']}\n          style={{ width: `${item.width}px` }}\n          id={`horizontal-dragger-item-${index}`}\n        >\n          <div\n            className={css['table-trigger']}\n            draggable\n            onMouseDown={(e) => {\n              startFromX = e.clientX\n              document.body.addEventListener(\n                'dragover',\n                onHandleDrag({ item, index }),\n                false\n              )\n            }}\n            onDragEnd={() => {\n              document.body.removeEventListener(\n                'dragover',\n                onHandleDrag({ item, index })\n              )\n              onHandleDragEnd(item, index)\n            }}\n          />\n        </div>\n      ))}\n    </div>\n  )\n}\n","import { NodeEntry, Transforms } from 'slate'\nimport React, { useCallback, useEffect, useRef, useState } from 'react'\n\nimport css from '../../style.module.css'\nimport { options } from '../../utils/options'\nimport { splittedTable } from '../../utils/selection'\nimport { useEditor } from 'slate-react'\n\nlet startFromY = 0\n\nexport const VerticalToolbar: React.FC<{\n  table: HTMLElement\n  tableNode: NodeEntry\n}> = ({ table, tableNode }) => {\n  const ref = useRef<HTMLDivElement>(null)\n  const editor = useEditor()\n  const [rows, setRows] = useState<{ height: number; el: HTMLElement[] }[]>([])\n  const heightFnObject = useRef({}).current\n\n  useEffect(() => {\n    const { gridTable = [] } = splittedTable(editor, tableNode)\n    if (!gridTable.length) return\n\n    const rowsArray = [] as { height: number; el: HTMLElement[] }[]\n\n    for (let i = 0; i < gridTable.length; i++) {\n      for (let j = 0; j < gridTable[i].length; j++) {\n        const currCell = gridTable[i][j]\n        const td = table.querySelector(\n          `[data-key=${currCell.cell.key}]`\n        ) as HTMLElement\n\n        if (!td) continue\n\n        if (!rowsArray[i]) {\n          rowsArray[i] = {\n            height: 0,\n            el: []\n          }\n        }\n\n        if (currCell.isReal) {\n          rowsArray[i].height = !rowsArray[i].height\n            ? td.offsetHeight\n            : Math.min(rowsArray[i].height, td.offsetHeight)\n        }\n\n        if (\n          rowsArray[i].el.findIndex(\n            ({ dataset }) => dataset.key === td.dataset.key\n          ) < 0\n        ) {\n          rowsArray[i].el.push(td)\n        }\n      }\n    }\n\n    setRows(() => rowsArray)\n  }, [editor, table, tableNode])\n\n  const onHandleDrag = useCallback(\n    ({ item, index }) => {\n      if (heightFnObject[index]) {\n        return heightFnObject[index]\n      }\n\n      const fn = function (e: React.MouseEvent | MouseEvent) {\n        const changedHeight = e.clientY - startFromY\n\n        if (!changedHeight || !e.clientY) {\n          return\n        }\n\n        if (item.el) {\n          const minHeight = options.defaultHeight\n\n          const dragger = ref.current?.querySelector(\n            `#vertical-dragger-item-${index}`\n          ) as HTMLElement\n\n          if (!dragger) return\n          const draggerHeight = dragger.offsetHeight\n\n          if (draggerHeight + changedHeight > minHeight) {\n            dragger.style.height = `${draggerHeight + changedHeight}px`\n          }\n\n          const savedChangedHeight = []\n          let moreThanMinHeight = true\n          for (const cell of item.el) {\n            if (cell.offsetHeight + changedHeight < minHeight) {\n              moreThanMinHeight = false\n              break\n            }\n\n            savedChangedHeight.push({\n              td: cell,\n              height: cell.offsetHeight + changedHeight\n            })\n          }\n\n          if (moreThanMinHeight) {\n            savedChangedHeight.forEach((item) => {\n              item.td.style.height = `${item.height}px`\n            })\n          }\n        }\n\n        startFromY = e.clientY\n      }\n\n      heightFnObject[index] = fn\n\n      return heightFnObject[index]\n    },\n    [heightFnObject]\n  )\n\n  const onHandleDragEnd = useCallback(\n    (item: { height: number; el: HTMLElement[] }, index: number) => {\n      if (item.el) {\n        for (const cell of item.el) {\n          Transforms.setNodes(\n            editor,\n            {\n              height: cell.offsetHeight\n            },\n            {\n              at: tableNode[1],\n              match: (n) => n.key === cell.dataset.key\n            }\n          )\n        }\n\n        const dragger = ref.current?.querySelector(\n          `#vertical-dragger-item-${index}`\n        ) as HTMLElement\n\n        const draggerHeight = dragger.offsetHeight\n\n        const newRows = Array.from(rows)\n        newRows[index] = {\n          height: draggerHeight,\n          el: item.el\n        }\n\n        setRows(() => newRows)\n      }\n    },\n    [rows, editor, tableNode]\n  )\n\n  return (\n    <div\n      contentEditable={false}\n      className={css['table-vertical-toolbar']}\n      ref={ref}\n    >\n      {rows.map((item, index) => (\n        <div\n          key={index}\n          className={css['table-dragger-item']}\n          style={{ height: `${item.height}px` }}\n          id={`vertical-dragger-item-${index}`}\n        >\n          <div\n            className={css['table-trigger']}\n            draggable\n            onMouseDown={(e) => {\n              startFromY = e.clientY\n              document.body.addEventListener(\n                'dragover',\n                onHandleDrag({ item, index }),\n                false\n              )\n            }}\n            onDragEnd={() => {\n              document.body.removeEventListener(\n                'dragover',\n                onHandleDrag({ item, index }),\n                false\n              )\n\n              onHandleDragEnd(item, index)\n            }}\n          />\n        </div>\n      ))}\n    </div>\n  )\n}\n","import { Editor, NodeEntry, Transforms } from 'slate'\nimport React, {\n  Fragment,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState\n} from 'react'\nimport { RenderElementProps, useSelected, useSlate } from 'slate-react'\nimport { addSelection, removeSelection } from '../../utils/selection'\n\nimport { HorizontalToolbar } from '../horizontal-toolbar'\nimport { VerticalToolbar } from '../vertical-toolbar'\nimport classnames from 'classnames'\nimport css from '../../style.module.css'\nimport { options } from '../../utils/options'\n\nexport const TableBody: React.FC<\n  {\n    table: NodeEntry | null\n  } & RenderElementProps\n> = (props) => {\n  const { table, children, element } = props\n  const editor = useSlate()\n  const selected = useSelected()\n  const ref = useRef<HTMLTableElement>(null)\n\n  const resizeTable = useCallback(() => {\n    if (ref.current) {\n      ref.current.querySelectorAll('td').forEach((cell) => {\n        Transforms.setNodes(\n          editor,\n          {\n            width: cell.offsetWidth,\n            height: cell.offsetHeight\n          },\n          {\n            at: [],\n            match: (n) => n.key === cell.dataset.key\n          }\n        )\n      })\n    }\n  }, [editor])\n\n  useEffect(() => {\n    resizeTable()\n  }, [resizeTable, selected, editor.selection])\n\n  useEffect(() => {\n    if (!selected) removeSelection(editor)\n  }, [selected, editor])\n\n  const [startKey, setStartKey] = useState<string>('')\n\n  const startNode = useMemo(() => {\n    const [node] = Editor.nodes(editor, {\n      match: (n) => n.key === startKey,\n      at: []\n    })\n\n    return node\n  }, [startKey, editor])\n\n  const ResizeToolbar = useMemo(() => {\n    return (\n      selected &&\n      ref.current &&\n      table && (\n        <Fragment>\n          <HorizontalToolbar table={ref.current} tableNode={table} />\n          <VerticalToolbar table={ref.current} tableNode={table} />\n        </Fragment>\n      )\n    )\n  }, [selected, table])\n\n  return (\n    <Fragment>\n      {ResizeToolbar}\n      <table\n        className={classnames(css.table, {\n          [css.borderless]: !!element.borderless\n        })}\n        slate-table-element='table'\n        ref={ref}\n        style={options.tableStyle}\n        onDragStart={(e) => e.preventDefault()}\n        onMouseDown={(e) => {\n          const cell = (e.target as HTMLBaseElement).closest('td')\n          const key = cell?.getAttribute('data-key') || ''\n          setStartKey(key)\n        }}\n        onMouseMove={(e) => {\n          const cell = (e.target as HTMLBaseElement).closest('td')\n          if (cell && startKey) {\n            const endKey = cell.getAttribute('data-key')\n\n            const [endNode] = Editor.nodes(editor, {\n              match: (n) => n.key === endKey,\n              at: []\n            })\n\n            addSelection(\n              editor,\n              table,\n              Editor.path(editor, startNode[1]),\n              Editor.path(editor, endNode[1])\n            )\n          }\n        }}\n        onMouseUp={() => {\n          setStartKey('')\n          resizeTable()\n        }}\n        onMouseLeave={() => {\n          setStartKey('')\n        }}\n      >\n        <tbody slate-table-element='tbody'>{children}</tbody>\n      </table>\n    </Fragment>\n  )\n}\n","/* eslint-disable no-useless-return */\nimport { Col, splittedTable } from './selection'\nimport { Editor, NodeEntry, Path, Transforms } from 'slate'\nimport {\n  TableCell,\n  createTableCell,\n  createTableRow\n} from '../../../../core/tools'\n\nexport function splitCell(table: NodeEntry, editor: Editor) {\n  const { selection } = editor\n  if (!selection || !table) return\n\n  const yIndex = table[1].length\n  const xIndex = table[1].length + 1\n\n  const { getCol } = splittedTable(editor, table)\n\n  const [start, end] = Editor.edges(editor, selection)\n  const [startNode] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell',\n    at: start\n  })\n\n  const [endNode] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell',\n    at: end\n  })\n\n  if (!startNode || !endNode) return\n\n  const [startCell] = getCol((n: Col) => n.cell.key === startNode[0].key)\n  const [endCell] = getCol((n: Col) => n.cell.key === endNode[0].key)\n\n  const [yStart, yEnd] = [startCell.path[yIndex], endCell.path[yIndex]]\n  const [xStart, xEnd] = [startCell.path[xIndex], endCell.path[xIndex]]\n\n  const sourceCells = [] as Col[]\n  const selectedCols = getCol((n: Col) => {\n    if (n.cell.selectedCell) {\n      return true\n    }\n\n    const [y, x] = n.path.slice(yIndex, xIndex + 1)\n    if (y >= yStart && y <= yEnd && x >= xStart && x <= xEnd) {\n      if (!n.isReal) {\n        const [sourceCell] = getCol(\n          (s: Col) => s.isReal && s.cell.key === n.cell.key\n        )\n        sourceCells.push(sourceCell)\n      }\n      return true\n    }\n\n    return false\n  })\n\n  selectedCols.push(...sourceCells)\n\n  const filterColsObject = selectedCols.reduce(\n    (p: { [key: string]: Col }, c: Col) => {\n      if (c.isReal) {\n        p[c.cell.key] = c\n      }\n      return p\n    },\n    {}\n  ) as { [key: string]: Col }\n\n  Object.values(filterColsObject).forEach((col: Col) => {\n    const { cell, isReal, originPath } = col\n    const { rowspan = 1, colspan = 1, children } = cell\n\n    if (isReal && (rowspan !== 1 || colspan !== 1)) {\n      Transforms.delete(editor, {\n        at: originPath\n      })\n\n      for (let i = 0; i < rowspan; i++) {\n        for (let j = 0; j < colspan; j++) {\n          const newPath = Array.from(originPath)\n          newPath[yIndex] += i\n\n          const newCell = createTableCell({\n            width: 0,\n            height: 0,\n            elements:\n              i === 0 && j === colspan - 1\n                ? (children[0].children as any)\n                : null\n          })\n\n          Transforms.insertNodes(editor, newCell, {\n            at: newPath\n          })\n        }\n      }\n    }\n  })\n}\n\nexport function insertAbove(table: NodeEntry, editor: Editor) {\n  const { selection } = editor\n  if (!selection || !table) return\n\n  const yIndex = table[1].length\n\n  const { gridTable, getCol } = splittedTable(editor, table)\n\n  const [startCell] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell'\n  })\n\n  const [insertPositionCol] = getCol(\n    (c: Col) => c.cell.key === startCell[0].key && c.isReal\n  )\n\n  let checkInsertEnable = true\n  const insertYIndex = insertPositionCol.path[yIndex]\n  const insertCols = new Map<string, Col>()\n\n  gridTable[insertYIndex].forEach((col: Col) => {\n    if (!col.isReal) {\n      const [originCol] = getCol(\n        (c: Col) => c.isReal && c.cell.key === col.cell.key\n      )\n\n      if (originCol.path[yIndex] === insertYIndex) {\n        insertCols.set(originCol.cell.key, originCol)\n      } else {\n        checkInsertEnable = false\n        return\n      }\n    } else {\n      insertCols.set(col.cell.key, col)\n    }\n  })\n\n  if (!checkInsertEnable) {\n    return\n  }\n\n  const newRow = createTableRow(insertCols.size)\n\n  ;[...insertCols.values()].forEach((col, index) => {\n    newRow.children[index].colspan = col.cell.colspan || 1\n  })\n\n  const [[, path]] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-row'\n  })\n\n  Transforms.insertNodes(editor, newRow, {\n    at: path\n  })\n}\n\nexport function insertBelow(table: NodeEntry, editor: Editor) {\n  const { selection } = editor\n  if (!selection || !table) return\n\n  const yIndex = table[1].length\n\n  const { gridTable, getCol } = splittedTable(editor, table)\n\n  const [startCell] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell'\n  })\n\n  const [insertPositionCol] = getCol(\n    (c: Col) => c.cell.key === startCell[0].key && c.isReal\n  )\n\n  let checkInsertEnable = true\n  const insertCols = new Map<string, Col>()\n\n  const y =\n    insertPositionCol.path[yIndex] + (insertPositionCol.cell.rowspan || 1) - 1\n\n  gridTable[y].forEach((col: Col) => {\n    const [originCol] = getCol(\n      (n: any) => n.isReal && n.cell.key === col.cell.key\n    )\n\n    const { cell, path } = originCol\n\n    if (!gridTable[y + 1]) {\n      insertCols.set(cell.key, originCol)\n    } else if (path[yIndex] + (cell.rowspan || 1) - 1 === y) {\n      insertCols.set(cell.key, originCol)\n    } else {\n      checkInsertEnable = false\n      return\n    }\n  })\n\n  if (!checkInsertEnable) {\n    return\n  }\n\n  const newRow = createTableRow(insertCols.size)\n\n  ;[...insertCols.values()].forEach((value, index) => {\n    newRow.children[index].colspan = value.cell.colspan || 1\n  })\n\n  const [[, path]] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-row'\n  })\n\n  for (let i = 1; i < startCell[0].rowspan; i++) {\n    path[yIndex] += 1\n  }\n\n  Transforms.insertNodes(editor, newRow, {\n    at: Path.next(path)\n  })\n}\n\nexport function insertLeft(table: NodeEntry, editor: Editor) {\n  const { selection } = editor\n  if (!selection || !table) return\n\n  const xIndex = table[1].length + 1\n\n  const { gridTable, getCol } = splittedTable(editor, table)\n\n  const [startCell] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell'\n  })\n\n  const [insertPositionCol] = getCol(\n    (c: Col) => c.cell.key === startCell[0].key && c.isReal\n  )\n\n  const x = insertPositionCol.path[xIndex]\n\n  const insertCols = new Map<string, Col>()\n  let checkInsertable = true\n\n  gridTable.forEach((row: Col[]) => {\n    const col = row[x]\n\n    if (col.isReal) {\n      insertCols.set(col.cell.key, col)\n    } else {\n      const [originCol] = getCol(\n        (n: Col) => n.cell.key === col.cell.key && n.isReal\n      )\n      const { cell, path } = originCol\n\n      if (path[xIndex] === x) {\n        insertCols.set(cell.key, originCol)\n      } else {\n        checkInsertable = false\n        return\n      }\n    }\n  })\n\n  if (!checkInsertable) {\n    return\n  }\n\n  insertCols.forEach((col: Col) => {\n    const newCell = createTableCell({\n      rowspan: col.cell.rowspan || 1\n    })\n\n    Transforms.insertNodes(editor, newCell, {\n      at: col.originPath\n    })\n  })\n}\n\nexport function insertRight(table: NodeEntry, editor: Editor) {\n  const { selection } = editor\n  if (!selection || !table) return\n\n  const xIndex = table[1].length + 1\n\n  const { gridTable, getCol } = splittedTable(editor, table)\n\n  const [startCell] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell'\n  })\n\n  const [insertPositionCol] = getCol(\n    (c: Col) => c.cell.key === startCell[0].key && c.isReal\n  )\n\n  const x =\n    insertPositionCol.path[xIndex] + (insertPositionCol.cell.colspan || 1) - 1\n\n  const insertCols = new Map<string, Col>()\n  let checkInsertable = true\n\n  gridTable.forEach((row: Col[]) => {\n    const col = row[x]\n\n    const [originCol] = getCol(\n      (n: Col) => n.cell.key === col.cell.key && n.isReal\n    )\n\n    const { cell, path } = originCol\n\n    if (\n      !row[x + 1] ||\n      (col.isReal && (!col.cell.colspan || col.cell.colspan === 1))\n    ) {\n      insertCols.set(cell.key, originCol)\n    } else {\n      if (path[xIndex] + (cell.colspan || 1) - 1 === x) {\n        insertCols.set(cell.key, originCol)\n      } else {\n        checkInsertable = false\n        return\n      }\n    }\n  })\n\n  if (!checkInsertable) {\n    return\n  }\n\n  insertCols.forEach((col: Col) => {\n    const newCell = createTableCell({\n      rowspan: col.cell.rowspan || 1\n    })\n\n    Transforms.insertNodes(editor, newCell, {\n      at: Path.next(col.originPath)\n    })\n  })\n}\n\nexport function mergeSelection(table: NodeEntry, editor: Editor) {\n  if (!table || !editor.selection) return\n\n  const startPoint = Editor.start(editor, editor.selection)\n  const [startCell] = Editor.nodes(editor, {\n    match: (n) => n.selectedCell as any,\n    at: startPoint\n  })\n\n  if (!startCell) return\n\n  const { gridTable } = splittedTable(editor, table, startCell[0].key as any)\n\n  const selectedTable = checkMerge(gridTable)\n  if (!selectedTable) return\n\n  const insertPositionCol = selectedTable[0][0]\n  const tmpContent: { [key: string]: Node[] } = {}\n\n  gridTable.forEach((row: Col[]) => {\n    row.forEach((col: Col) => {\n      if (\n        col.cell.selectedCell &&\n        col.cell.key !== insertPositionCol.cell.key &&\n        col.isReal\n      ) {\n        const [node] = Editor.nodes(editor, {\n          match: (n) => n.key === col.cell.key,\n          at: []\n        })\n\n        if (node) {\n          if (Editor.string(editor, node[1])) {\n            tmpContent[col.cell.key] = node[0].children as any\n          }\n\n          Transforms.removeNodes(editor, {\n            at: table[1],\n            match: (n) => n.key === col.cell.key\n          })\n        }\n      }\n    })\n  })\n\n  Transforms.setNodes(\n    editor,\n    {\n      height: 0,\n      width: 0,\n      colspan: selectedTable[0].length,\n      rowspan: selectedTable.length\n    },\n    {\n      at: table[1],\n      match: (n) => n.key === insertPositionCol.cell.key\n    }\n  )\n\n  Transforms.removeNodes(editor, {\n    at: table[1],\n    match: (n) => {\n      if (n.type !== 'table-row') {\n        return false\n      }\n\n      if (\n        !n.children ||\n        (n.children as any).findIndex(\n          (cell: TableCell) => cell.type === 'table-cell'\n        ) < 0\n      ) {\n        return true\n      }\n\n      return false\n    }\n  })\n\n  const rows = Editor.nodes(editor, {\n    at: table[1],\n    match: (n) => n.type === 'table-row'\n  })\n\n  for (const row of rows) {\n    let minRowHeight = Infinity\n    ;(row[0].children as any).forEach((cell: TableCell) => {\n      const { rowspan = 1 } = cell\n      if (rowspan < minRowHeight) {\n        minRowHeight = rowspan\n      }\n    })\n\n    if (minRowHeight > 1 && minRowHeight < Infinity) {\n      ;(row[0].children as any).forEach((cell: TableCell) => {\n        Transforms.setNodes(\n          editor,\n          {\n            height: 0,\n            width: 0,\n            rowspan: (cell.rowspan || 1) - minRowHeight + 1\n          },\n          {\n            at: table[1],\n            match: (n) => n.key === cell.key\n          }\n        )\n      })\n    }\n  }\n\n  const { gridTable: mergedGridTable } = splittedTable(editor, table)\n  for (let idx = 0; idx < mergedGridTable[0].length; idx++) {\n    let allColumnIsReal = true\n    let minColWidth = Infinity\n\n    for (let j = 0; j < mergedGridTable.length; j++) {\n      if (!mergedGridTable[j][idx]) continue\n\n      if (!mergedGridTable[j][idx].isReal) {\n        allColumnIsReal = false\n      } else {\n        const { colspan = 1 } = mergedGridTable[j][idx].cell\n        if (colspan < minColWidth) {\n          minColWidth = colspan\n        }\n      }\n    }\n\n    if (allColumnIsReal && minColWidth < Infinity && minColWidth > 1) {\n      for (let j = 0; j < mergedGridTable.length; j++) {\n        const { cell } = mergedGridTable[j][idx]\n        Transforms.setNodes(\n          editor,\n          {\n            height: 0,\n            width: 0,\n            colspan: (cell.colspan || 1) - minColWidth + 1\n          },\n          {\n            at: table[1],\n            match: (n) => n.key === cell.key\n          }\n        )\n      }\n    }\n  }\n\n  const [insertContents] = Editor.nodes(editor, {\n    at: insertPositionCol.originPath,\n    match: (n) => n.type === 'table-content'\n  })\n\n  Object.values(tmpContent).forEach((content) => {\n    if (content[0] && (content[0] as any).children) {\n      Transforms.insertNodes(editor, (content[0] as any).children, {\n        at: Editor.end(editor, insertContents[1])\n      })\n    }\n  })\n}\n\nexport function removeColumn(table: NodeEntry, editor: Editor) {\n  const { selection } = editor\n  if (!selection || !table) return\n\n  const { gridTable, getCol } = splittedTable(editor, table)\n  const xIndex = table[1].length + 1\n\n  const [start, end] = Editor.edges(editor, selection)\n  const [startNode] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell',\n    at: start\n  })\n\n  const [endNode] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell',\n    at: end\n  })\n\n  const [startCol] = getCol((col: Col) => col.cell.key === startNode[0].key)\n  const [endCol] = getCol((col: Col) => col.cell.key === endNode[0].key)\n\n  const xLeft = startCol.path[xIndex]\n  const xRight = endCol.path[xIndex]\n\n  const topLeftCol = gridTable[0][xLeft]\n  const bottomRight = gridTable[gridTable.length - 1][xRight]\n\n  Transforms.setSelection(editor, {\n    anchor: Editor.point(editor, topLeftCol.originPath),\n    focus: Editor.point(editor, bottomRight.originPath)\n  })\n\n  splitCell(table, editor)\n\n  const { gridTable: splitedGridTable } = splittedTable(editor, table)\n\n  const removedCells = splitedGridTable.reduce((p: Col[], c: Col[]) => {\n    const cells = c.slice(xLeft, xRight + 1)\n    return [...p, ...cells]\n  }, []) as Col[]\n\n  removedCells.forEach((cell: { cell: { key: any } }) => {\n    Transforms.removeNodes(editor, {\n      at: table[1],\n      match: (n) => n.key === cell.cell.key\n    })\n  })\n\n  Transforms.removeNodes(editor, {\n    at: table[1],\n    match: (n) => {\n      if (n.type !== 'table-row') {\n        return false\n      }\n\n      if (\n        !n.children ||\n        (n.children as any).findIndex(\n          (cell: TableCell) => cell.type === 'table-cell'\n        ) < 0\n      ) {\n        return true\n      }\n\n      return false\n    }\n  })\n\n  const rows = Editor.nodes(editor, {\n    at: table[1],\n    match: (n) => n.type === 'table-row'\n  })\n\n  for (const row of rows) {\n    let minRowHeight = Infinity\n    ;(row[0].children as any).forEach((cell: TableCell) => {\n      const { rowspan = 1 } = cell\n      if (rowspan < minRowHeight) {\n        minRowHeight = rowspan\n      }\n    })\n\n    if (minRowHeight > 1 && minRowHeight < Infinity) {\n      ;(row[0].children as any).forEach((cell: TableCell) => {\n        Transforms.setNodes(\n          editor,\n          {\n            rowspan: (cell.rowspan || 1) - minRowHeight + 1\n          },\n          {\n            at: table[1],\n            match: (n) => n.key === cell.key\n          }\n        )\n      })\n    }\n  }\n\n  const { gridTable: removedGridTable } = splittedTable(editor, table)\n\n  if (!removedGridTable.length) {\n    const contentAfterRemove = Editor.string(editor, table[1])\n\n    if (!contentAfterRemove) {\n      Transforms.removeNodes(editor, {\n        at: table[1]\n      })\n    }\n\n    return\n  }\n\n  for (let idx = 0; idx < removedGridTable[0].length; idx++) {\n    let allColumnIsReal = true\n    let minColWidth = Infinity\n\n    for (let j = 0; j < removedGridTable.length; j++) {\n      if (!removedGridTable[j][idx].isReal) {\n        allColumnIsReal = false\n      } else {\n        const { colspan = 1 } = removedGridTable[j][idx].cell\n        if (colspan < minColWidth) {\n          minColWidth = colspan\n        }\n      }\n    }\n\n    if (allColumnIsReal && minColWidth < Infinity && minColWidth > 1) {\n      for (let j = 0; j < removedGridTable.length; j++) {\n        const { cell } = removedGridTable[j][idx]\n        Transforms.setNodes(\n          editor,\n          {\n            colspan: (cell.colspan || 1) - minColWidth + 1\n          },\n          {\n            at: table[1],\n            match: (n) => n.key === cell.key\n          }\n        )\n      }\n    }\n  }\n}\n\nexport function removeRow(table: NodeEntry, editor: Editor) {\n  const { selection } = editor\n  if (!selection || !table) return\n\n  const { gridTable, getCol } = splittedTable(editor, table)\n\n  const yIndex = table[1].length\n\n  const [start, end] = Editor.edges(editor, selection)\n  const [startNode] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell',\n    at: start\n  })\n\n  const [endNode] = Editor.nodes(editor, {\n    match: (n) => n.type === 'table-cell',\n    at: end\n  })\n\n  const [startCol] = getCol((col: Col) => col.cell.key === startNode[0].key)\n  const [endCol] = getCol((col: Col) => col.cell.key === endNode[0].key)\n\n  const yTop = startCol.path[yIndex]\n  const yBottom = endCol.path[yIndex]\n\n  const topLeftCol = gridTable[yTop][0]\n  const bottomRight = gridTable[yBottom][gridTable[yBottom].length - 1]\n\n  Transforms.setSelection(editor, {\n    anchor: Editor.point(editor, topLeftCol.originPath),\n    focus: Editor.point(editor, bottomRight.originPath)\n  })\n\n  splitCell(table, editor)\n\n  const { gridTable: splitedGridTable } = splittedTable(editor, table)\n\n  const removeCols = splitedGridTable\n    .slice(yTop, yBottom + 1)\n    .reduce((p: Col[], c: Col[]) => [...p, ...c], []) as Col[]\n\n  removeCols.forEach((col: Col) => {\n    Transforms.removeNodes(editor, {\n      at: table[1],\n      match: (n) => n.key === col.cell.key\n    })\n  })\n\n  Transforms.removeNodes(editor, {\n    at: table[1],\n    match: (n) => {\n      if (n.type !== 'table-row') {\n        return false\n      }\n\n      if (\n        !n.children ||\n        (n.children as any).findIndex(\n          (cell: TableCell) => cell.type === 'table-cell'\n        ) < 0\n      ) {\n        return true\n      }\n\n      return false\n    }\n  })\n\n  if (!Editor.string(editor, table[1])) {\n    Transforms.removeNodes(editor, {\n      at: table[1]\n    })\n  }\n}\n\nexport function removeTable(table: NodeEntry, editor: Editor) {\n  if (editor && table) {\n    Transforms.removeNodes(editor, {\n      match: (n) => n.type === 'table',\n      at: table[1]\n    })\n  }\n}\n\nexport function toggleBorders(table: NodeEntry, editor: Editor) {\n  if (editor && table) {\n    Transforms.setNodes(\n      editor,\n      {\n        borderless: !table[0].borderless\n      },\n      {\n        match: (n) => n.type === 'table',\n        at: table[1]\n      }\n    )\n  }\n}\n\nfunction checkMerge(table: Col[][]): Col[][] | undefined {\n  let selectedCount = 0\n\n  const selectedTable = table.reduce((t: Col[][], row: Col[]) => {\n    const currRow = row.filter((col: Col) => col.cell.selectedCell)\n    if (currRow.length) {\n      t.push(currRow)\n      selectedCount += currRow.length\n    }\n    return t\n  }, [])\n\n  if (selectedCount < 2) {\n    return undefined\n  }\n\n  const selectedWidth = selectedTable[0].length\n  let couldMerge = true\n\n  selectedTable.forEach((row: Col[]) => {\n    if (row.length !== selectedWidth) {\n      couldMerge = false\n    }\n  })\n\n  if (!couldMerge) {\n    return undefined\n  }\n\n  return selectedTable\n}\n","import { useState, useCallback, useMemo, MouseEvent, useContext } from 'react'\nimport { useSlate } from 'slate-react'\nimport OrphanNodesContext from '../contexts/orphan-nodes'\nimport {\n  BlockAlignment,\n  getAlignment,\n  getColorMark,\n  HeadingFormatType,\n  isBlockActive,\n  isMarkActive,\n  SlateEditorType\n} from '../tools'\n\ntype PopupActions = {\n  visible: boolean\n  open: Fn\n  close: Fn\n  toggle: Fn\n}\n\nexport type TextSizeValue = {\n  name: HeadingFormatType\n  label: string\n  value: boolean\n}\n\nexport function usePopupUtils(initialOpen: boolean = false): PopupActions {\n  const [visible, setVisible] = useState(initialOpen)\n\n  const handleOpen = useCallback(() => {\n    setVisible(true)\n  }, [])\n\n  const handleClose = useCallback(() => {\n    setVisible(false)\n  }, [])\n\n  const handleToggle = useCallback(() => {\n    setVisible((o) => !o)\n  }, [])\n\n  const popupActions: PopupActions = useMemo(\n    () => ({\n      visible,\n      open: handleOpen,\n      close: handleClose,\n      toggle: handleToggle\n    }),\n    [handleClose, handleOpen, handleToggle, visible]\n  )\n\n  return popupActions\n}\n\nexport function useEditor(): SlateEditorType {\n  return useSlate() as SlateEditorType\n}\n\nexport function useTextSizeValue(): TextSizeValue {\n  const editor = useEditor()\n\n  const headingOneActive = isBlockActive(editor, 'heading-one')\n  const headingTwoActive = isBlockActive(editor, 'heading-two')\n  const headingThreeActive = isBlockActive(editor, 'heading-three')\n\n  const results = useMemo(\n    () =>\n      [\n        { name: 'heading-one', label: 'Heading 1', value: headingOneActive },\n        { name: 'heading-two', label: 'Heading 2', value: headingTwoActive },\n        { name: 'heading-three', label: 'Heading 3', value: headingThreeActive }\n      ] as Array<TextSizeValue>,\n    [headingOneActive, headingThreeActive, headingTwoActive]\n  )\n\n  return results.find((o) => o.value)\n}\n\nexport function useLeafColorValue(): string {\n  const editor = useEditor()\n  return getColorMark(editor)\n}\n\nexport function useAlignmentValue(): BlockAlignment {\n  const editor = useEditor()\n  return getAlignment(editor)\n}\n\nexport function useMouseDown(fn: Fn): (e: MouseEvent) => void {\n  return useCallback(\n    (e: MouseEvent) => {\n      e?.preventDefault()\n      fn?.()\n    },\n    [fn]\n  )\n}\n\nexport function useCanUndo(): boolean {\n  const editor = useEditor()\n  return !!editor.history?.undos?.length\n}\n\nexport function useCanRedo(): boolean {\n  const editor = useEditor()\n  return !!editor.history?.redos?.length\n}\n\nexport function useConditionActive(): boolean {\n  const editor = useEditor()\n  return isMarkActive(editor, 'ref')\n}\n\nexport function useOrphanNodes() {\n  const context = useContext(OrphanNodesContext)\n  return context\n}\n","import React, {\n  Children,\n  cloneElement,\n  FC,\n  memo,\n  PropsWithChildren,\n  ReactElement\n} from 'react'\nimport classnames from 'classnames'\nimport { useMouseDown } from '../../core/hooks'\n\ntype IconProps = PropsWithChildren<{\n  className?: string\n  onPress?: Fn\n}>\n\nconst BaseIcon: FC<IconProps> = ({ children, className, onPress }) => {\n  const handlePress = useMouseDown(onPress)\n  return (\n    <figure\n      onMouseDown={handlePress}\n      className={classnames('flex-shrink-0', className, {\n        's-16': !/\\bs-[0-9]/gi.test(className)\n      })}\n    >\n      {Children.map(children, (child: ReactElement) =>\n        cloneElement(child, {\n          className: classnames(\n            child.props.className,\n            'h-full w-full object-contain object-center m-auto pointer-events-none'\n          )\n        })\n      )}\n    </figure>\n  )\n}\n\nconst Icon = memo(BaseIcon)\n\nexport default Icon\n","import React, { ReactNode, Ref, forwardRef } from 'react'\n\nimport Icon from '../icon'\nimport classnames from 'classnames'\nimport css from './style.module.css'\nimport { useMouseDown } from '../../core/hooks'\n\ntype IconButtonProps = {\n  active?: boolean\n  disabled?: boolean\n  className?: string\n  data?: string\n  tip?: string\n  onPress?: Fn\n  children?: ReactNode\n}\n\nconst BaseIconButton = (\n  {\n    active,\n    data,\n    disabled,\n    className,\n    children,\n    onPress,\n    tip\n  }: IconButtonProps,\n  ref: Ref<HTMLDivElement>\n) => {\n  const handlePress = useMouseDown(() => {\n    onPress?.(data)\n  })\n\n  return (\n    <div\n      ref={ref}\n      className={classnames(\n        's-32 rounded-default bg-transparent cursor-pointer flex items-center justify-center transition-colors duration-250 hover:bg-blue-100 hover:text-blue-500',\n        {\n          'text-blue-500 bg-blue-highlight': active,\n          'pointer-events-none opacity-50': disabled,\n          [css.tooltip]: !!tip?.length\n        },\n        className\n      )}\n      data-tip={tip}\n      onMouseDown={handlePress}\n    >\n      <Icon className='s-20'>{children}</Icon>\n    </div>\n  )\n}\n\nconst IconButton = forwardRef(BaseIconButton)\n\nexport default IconButton\n","import React, { FC } from 'react'\n\nimport classnames from 'classnames'\n\ntype IconGroupProps = {\n  className?: string\n}\n\nconst IconGroup: FC<IconGroupProps> = ({ className, children }) => {\n  return (\n    <div className={classnames('flex items-center space-x-4', className)}>\n      {children}\n    </div>\n  )\n}\n\nIconGroup.defaultProps = {\n  className: 'px-16'\n}\n\nexport default IconGroup\n","import React, { HTMLAttributes } from 'react'\n\nimport { AiOutlineDelete } from '@react-icons/all-files/ai/AiOutlineDelete'\nimport IconButton from '../../../../icon-button'\nimport IconGroup from '../../../../icon-group'\nimport classnames from 'classnames'\nimport css from './style.module.css'\n\ninterface CardbarProps extends HTMLAttributes<HTMLDivElement> {\n  delete?: () => void\n}\n\nconst exec = (func: Function, ...args: any[]) => (e?: React.MouseEvent) => {\n  e && e.preventDefault()\n  return func(...args)\n}\n\nexport const Cardbar: React.FC<CardbarProps> = (props) => {\n  return (\n    <div className={classnames(css.cardbar, props.className)}>\n      <IconGroup className='px-0 text-gray-500 bg-blue-50 rounded-default'>\n        {props.children}\n        {props.delete && (\n          <IconButton onPress={exec(props.delete)} tip='Delete table'>\n            <AiOutlineDelete />\n          </IconButton>\n        )}\n      </IconGroup>\n    </div>\n  )\n}\n","import React, { HTMLAttributes } from 'react'\nimport {\n  insertAbove,\n  insertBelow,\n  insertLeft,\n  insertRight,\n  mergeSelection,\n  removeColumn,\n  removeRow,\n  removeTable,\n  splitCell,\n  toggleBorders\n} from '../../utils/commands'\n\nimport { AiOutlineBorderInner } from '@react-icons/all-files/ai/AiOutlineBorderInner'\nimport { AiOutlineDeleteColumn } from '@react-icons/all-files/ai/AiOutlineDeleteColumn'\nimport { AiOutlineDeleteRow } from '@react-icons/all-files/ai/AiOutlineDeleteRow'\nimport { AiOutlineInsertRowAbove } from '@react-icons/all-files/ai/AiOutlineInsertRowAbove'\nimport { AiOutlineInsertRowBelow } from '@react-icons/all-files/ai/AiOutlineInsertRowBelow'\nimport { AiOutlineInsertRowLeft } from '@react-icons/all-files/ai/AiOutlineInsertRowLeft'\nimport { AiOutlineInsertRowRight } from '@react-icons/all-files/ai/AiOutlineInsertRowRight'\nimport { AiOutlineMergeCells } from '@react-icons/all-files/ai/AiOutlineMergeCells'\nimport { AiOutlineSplitCells } from '@react-icons/all-files/ai/AiOutlineSplitCells'\nimport { Cardbar } from '../cardbar'\nimport { Editor } from 'slate'\nimport IconButton from '../../../../icon-button'\nimport classnames from 'classnames'\nimport css from '../../style.module.css'\nimport { useSlate } from 'slate-react'\n\ninterface TableCardbarProps extends HTMLAttributes<HTMLDivElement> {}\n\nexport const TableCardbar: React.FC<TableCardbarProps> = (props) => {\n  const editor = useSlate()\n\n  const [table] = Array.from(\n    Editor.nodes(editor, {\n      match: (n) => n.type === 'table'\n    })\n  )\n\n  const run = (action: (table: any, editor: Editor) => any) => () =>\n    action(table, editor)\n\n  const getIsBorderActive = () => {\n    if (!table) {\n      return false\n    }\n\n    return !table?.[0].borderless\n  }\n\n  return (\n    <Cardbar\n      className={classnames(props.className, css['table-cardbar'])}\n      delete={run(removeTable)}\n    >\n      <IconButton onPress={run(insertAbove)} tip='Insert row above'>\n        <AiOutlineInsertRowAbove />\n      </IconButton>\n      <IconButton onPress={run(insertBelow)} tip='Insert row below'>\n        <AiOutlineInsertRowBelow />\n      </IconButton>\n      <IconButton onPress={run(insertLeft)} tip='Insert column left'>\n        <AiOutlineInsertRowLeft />\n      </IconButton>\n      <IconButton onPress={run(insertRight)} tip='Insert column right'>\n        <AiOutlineInsertRowRight />\n      </IconButton>\n      <IconButton onPress={run(mergeSelection)} tip='Merge selection'>\n        <AiOutlineMergeCells />\n      </IconButton>\n      <IconButton onPress={run(removeColumn)} tip='Remove column'>\n        <AiOutlineDeleteColumn />\n      </IconButton>\n      <IconButton onPress={run(removeRow)} tip='Remove row'>\n        <AiOutlineDeleteRow />\n      </IconButton>\n      <IconButton onPress={run(splitCell)} tip='Split cell'>\n        <AiOutlineSplitCells />\n      </IconButton>\n      <IconButton\n        active={getIsBorderActive()}\n        onPress={run(toggleBorders)}\n        tip='Toggle borders'\n      >\n        <AiOutlineBorderInner />\n      </IconButton>\n    </Cardbar>\n  )\n}\n","import React from 'react'\nimport { RenderElementProps } from 'slate-react'\nimport classnames from 'classnames'\nimport css from '../../style.module.css'\n\nexport const TableCell: React.FC<\n  {\n    node: {\n      width: number\n      height: number\n      selectedCell?: boolean\n      colspan?: number\n      rowspan?: number\n    }\n    dataKey: string\n  } & RenderElementProps\n> = ({ attributes, node, dataKey, children }) => {\n  const { selectedCell } = node\n\n  return (\n    <td\n      {...attributes}\n      className={classnames(css['table-td'], {\n        [css.selectedCell]: selectedCell\n      })}\n      slate-table-element='td'\n      data-key={dataKey}\n      colSpan={node.colspan}\n      rowSpan={node.rowspan}\n      onDragStart={(e) => e.preventDefault()}\n      style={{\n        position: 'relative',\n        minWidth: '50px',\n        width: node.width ? `${node.width}px` : 'auto',\n        height: node.width ? `${node.height}px` : 'auto'\n      }}\n    >\n      {children}\n    </td>\n  )\n}\n","import { Editor, NodeEntry } from 'slate'\nimport { RenderElementProps, useEditor, useSelected } from 'slate-react'\n\nimport React from 'react'\nimport { TableBody } from './modules/table-body'\nimport { TableCardbar } from './modules/table-cardbar'\nimport { TableCell } from './modules/table-cell'\nimport classnames from 'classnames'\nimport css from './style.module.css'\n\nexport const Table: React.FC<RenderElementProps> = (props) => {\n  const { attributes, children, element } = props\n  const selected = useSelected()\n  const editor = useEditor()\n\n  switch (element.type) {\n    case 'table': {\n      let existSelectedCell = false\n      let table: NodeEntry | null = null\n\n      if (selected && editor.selection) {\n        ;[table] = Editor.nodes(editor, {\n          match: (n) => n.type === 'table',\n          at: Editor.path(editor, editor.selection)\n        })\n\n        if (table) {\n          const [selectedCell] = Editor.nodes(editor, {\n            at: Editor.range(editor, table[1]),\n            match: (n) => n.selectedCell as any\n          })\n\n          if (selectedCell) {\n            existSelectedCell = true\n          }\n        }\n      }\n\n      return (\n        <div style={{ position: 'relative' }}>\n          <TableCardbar\n            className={classnames({ selected: selected || existSelectedCell })}\n          />\n          <TableBody {...props} table={table}>\n            {children}\n          </TableBody>\n        </div>\n      )\n    }\n\n    case 'table-row': {\n      return (\n        <tr\n          {...attributes}\n          className={css['table-tr']}\n          slate-table-element='tr'\n          data-key={element.key}\n          onDrag={(e) => e.preventDefault()}\n        >\n          {children}\n        </tr>\n      )\n    }\n\n    case 'table-cell': {\n      return (\n        <TableCell\n          {...props}\n          dataKey={element.key as any}\n          node={children.props.node}\n        >\n          {children}\n        </TableCell>\n      )\n    }\n\n    case 'table-content': {\n      return (\n        <div slate-table-element='content' className={css['table-content']}>\n          {children}\n        </div>\n      )\n    }\n\n    default:\n      return <p {...props} />\n  }\n}\n","import {\n  BlockAlignment,\n  EditableAttributes,\n  EditableElementType,\n  composeWithAlignmentClassName,\n  composeWithStyle,\n  getIndentationPercent\n} from '../../core/tools'\nimport ImageElement, { ImageElementType } from '../elements/image'\nimport React, { FC, PropsWithChildren } from 'react'\n\nimport EditableElement from '../elements/editable'\nimport { Table } from '../elements/table'\n\nexport type ElementType =\n  | 'quote'\n  | 'code'\n  | 'bulleted-list'\n  | 'heading-one'\n  | 'heading-two'\n  | 'heading-three'\n  | 'heading-four'\n  | 'heading-five'\n  | 'heading-six'\n  | 'list-item'\n  | 'numbered-list'\n  | 'link'\n  | 'table'\n  | 'table-row'\n  | 'table-cell'\n  | 'table-content'\n  | 'image'\n  | 'editable'\n\ntype TemplateElementType = {\n  type: ElementType\n  alignment?: BlockAlignment\n  indentation?: number\n  children: any\n} & ImageElementType &\n  EditableElementType<EditableAttributes>\n\ntype TemplateElementProps = PropsWithChildren<{\n  attributes: any\n  element: TemplateElementType\n}>\n\nconst TemplateElement: FC<TemplateElementProps> = ({\n  attributes,\n  children,\n  element\n}) => {\n  const { type, url, alignment, indentation, dataType } = element\n\n  switch (type) {\n    default:\n      return (\n        <p\n          {...composeWithStyle(\n            composeWithAlignmentClassName(attributes, alignment),\n            { paddingLeft: getIndentationPercent(indentation) }\n          )}\n        >\n          {children}\n        </p>\n      )\n    case 'quote':\n      return <blockquote {...attributes}>{children}</blockquote>\n    case 'code':\n      return (\n        <pre>\n          <code {...attributes}>{children}</code>\n        </pre>\n      )\n    case 'bulleted-list':\n      return (\n        <ul\n          {...composeWithAlignmentClassName(\n            attributes,\n            alignment,\n            'list-disc list-inside'\n          )}\n        >\n          {children}\n        </ul>\n      )\n    case 'heading-one':\n      return (\n        <h1\n          {...composeWithStyle(\n            composeWithAlignmentClassName(\n              attributes,\n              alignment,\n              'text-heading-2'\n            ),\n            { paddingLeft: getIndentationPercent(indentation) }\n          )}\n        >\n          {children}\n        </h1>\n      )\n    case 'heading-two':\n      return (\n        <h2\n          {...composeWithStyle(\n            composeWithAlignmentClassName(\n              attributes,\n              alignment,\n              'text-heading-3'\n            ),\n            { paddingLeft: getIndentationPercent(indentation) }\n          )}\n        >\n          {children}\n        </h2>\n      )\n    case 'heading-three':\n      return (\n        <h3\n          {...(composeWithStyle(\n            composeWithAlignmentClassName(\n              attributes,\n              alignment,\n              'text-headline'\n            )\n          ),\n          { paddingLeft: getIndentationPercent(indentation) })}\n        >\n          {children}\n        </h3>\n      )\n    case 'heading-four':\n      return <h4 {...attributes}>{children}</h4>\n    case 'heading-five':\n      return <h5 {...attributes}>{children}</h5>\n    case 'heading-six':\n      return <h6 {...attributes}>{children}</h6>\n    case 'list-item':\n      return (\n        <li\n          {...composeWithStyle(attributes, {\n            paddingLeft: getIndentationPercent(indentation)\n          })}\n        >\n          {children}\n        </li>\n      )\n    case 'numbered-list':\n      return (\n        <ol\n          {...composeWithAlignmentClassName(\n            attributes,\n            alignment,\n            'list-decimal list-inside'\n          )}\n        >\n          {children}\n        </ol>\n      )\n    case 'link':\n      return (\n        <a href={url} {...attributes}>\n          {children}\n        </a>\n      )\n    case 'table':\n    case 'table-row':\n    case 'table-cell':\n    case 'table-content':\n      return <Table {...{ attributes, children, element }} />\n    case 'image':\n      return <ImageElement {...{ attributes, children, element }} />\n    case 'editable':\n      return dataType === 'image' ? (\n        <ImageElement {...{ attributes, children, element }} />\n      ) : (\n        <EditableElement {...{ attributes, children, element }} />\n      )\n  }\n}\n\nexport default TemplateElement\n","import React, { FC, PropsWithChildren } from 'react'\nimport {\n  composeWithClassName,\n  composeWithStyle,\n  EditableRefAttributes\n} from '../../core/tools'\nimport classnames from 'classnames'\nimport { notNil } from '../../core/utils'\n\nexport type TemplateLeafType = Partial<{\n  bold: boolean\n  code: boolean\n  italic: boolean\n  underline: boolean\n  strikethrough: boolean\n  color: string\n  ref: EditableRefAttributes\n}>\n\ntype TemplateLeafProps = PropsWithChildren<{\n  attributes: any\n  leaf: TemplateLeafType\n}>\n\nconst TemplateLeaf: FC<TemplateLeafProps> = ({\n  attributes,\n  children,\n  leaf\n}) => {\n  if (leaf.bold) {\n    children = <strong>{children}</strong>\n  }\n\n  if (leaf.code) {\n    children = <code>{children}</code>\n  }\n\n  if (leaf.italic) {\n    children = <em>{children}</em>\n  }\n\n  if (leaf.underline) {\n    children = <u>{children}</u>\n  }\n\n  if (leaf.strikethrough) {\n    children = <del>{children}</del>\n  }\n\n  return (\n    <span\n      {...composeWithClassName(\n        composeWithStyle(attributes, { color: leaf.color }),\n        classnames({ 'bg-green-highlight': notNil(leaf.ref) })\n      )}\n    >\n      {children}\n    </span>\n  )\n}\n\nexport default TemplateLeaf\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import classnames from 'classnames'\nimport React, { useLayoutEffect, useState } from 'react'\n\nimport css from './style.module.css'\n\nexport type ContentDimensions = {\n  width?: number\n  height?: number\n  x?: number\n  y?: number\n}\n\ntype ContentProps = {\n  onLayoutUpdate: (dimensions: ContentDimensions) => void\n  x?: number\n  y?: number\n  hideArrow?: boolean\n  position?: string\n  alignment?: string\n  className?: string\n}\n\nconst Content: React.FC<ContentProps> = ({\n  onLayoutUpdate,\n  children,\n  x,\n  y,\n  position,\n  alignment,\n  className,\n  hideArrow\n}) => {\n  const [dimensions, setDimensions] = useState<ContentDimensions>({ x, y })\n\n  useLayoutEffect(() => {\n    const element = document.querySelector(`.${css.container}`)\n    const { width, height, x, y } = element.getBoundingClientRect()\n    const computedDimensions: ContentDimensions = { width, height, x, y }\n\n    if (JSON.stringify(computedDimensions) !== JSON.stringify(dimensions)) {\n      setDimensions(computedDimensions)\n      onLayoutUpdate(computedDimensions)\n    }\n  }, [dimensions, onLayoutUpdate])\n\n  let composedClassName = css.container\n  const arrowClassName = ` ${css.arrow} ${css[`arrow${position}`]} ${\n    css[`arrow${alignment}`]\n  }`\n\n  if (!hideArrow) composedClassName += arrowClassName\n\n  return (\n    <div\n      className={classnames(composedClassName, 'shadow-6', className)}\n      style={{ top: y, left: x }}\n    >\n      {children}\n    </div>\n  )\n}\n\nContent.defaultProps = {\n  x: 0,\n  y: 0\n}\n\nexport default Content\n","import Content, { ContentDimensions } from './content'\nimport React, {\n  MutableRefObject,\n  useCallback,\n  useEffect,\n  useState\n} from 'react'\n\n// import { createPortal } from 'react-dom'\nimport { useMouseDown } from '../../core/hooks'\n\nexport type AnchorRef = MutableRefObject<Element>\n\nexport type PopupPosition = 'up' | 'right' | 'down' | 'left' | 'center'\n\nexport type PopupAlignment = 'start' | 'center' | 'end'\n\ntype PopupOffset = {\n  x: number\n  y: number\n}\n\ntype PopupContentPosition = {\n  x: number\n  y: number\n}\n\ntype PopupProps = {\n  anchor?: string\n  anchorRef?: AnchorRef\n  contentClassName?: string\n  position?: PopupPosition\n  alignment?: PopupAlignment\n  transparent?: boolean\n  distance?: number\n  offsets?: PopupOffset\n  hideArrow?: boolean\n  isVisible?: boolean\n  overlayCloseOnClick?: boolean\n  onRequestClose: () => void\n}\n\nconst EDGE_PADDING = 12\n\nconst getViewportWidth = () =>\n  window.innerWidth ||\n  document.documentElement.clientWidth ||\n  document.body.clientWidth\n\nconst getViewportHeight = () =>\n  window.innerHeight ||\n  document.documentElement.clientHeight ||\n  document.body.clientHeight\n\nconst getPositioningWithoutAnchor = (\n  dimensions: ContentDimensions,\n  position: PopupPosition,\n  alignment: PopupAlignment\n) => {\n  const viewportWidth = getViewportWidth()\n  const viewportHeight = getViewportHeight()\n  const { width, height } = dimensions\n\n  let x: number, y: number\n\n  switch (position) {\n    case 'up':\n      y = 0\n      break\n    case 'down':\n      y = viewportHeight - height\n      break\n    case 'center':\n      y = (viewportHeight - height) / 2\n      break\n    default:\n      y = 0\n      break\n  }\n\n  switch (alignment) {\n    case 'start':\n      x = 0\n      break\n    case 'center':\n      x = (viewportWidth - width) / 2\n      break\n    case 'end':\n      x = viewportWidth - width\n      break\n    default:\n      x = 0\n      break\n  }\n\n  return { x, y }\n}\n\nconst getPositioningWithAnchor = (\n  dimensions: ContentDimensions,\n  anchor: string,\n  anchorRef: AnchorRef,\n  distance: number,\n  position: PopupPosition,\n  alignment: PopupAlignment\n) => {\n  const anchorElement = anchorRef.current || document.querySelector(anchor)\n  if (!anchorElement)\n    return getPositioningWithoutAnchor(dimensions, position, alignment)\n\n  const {\n    width: anchorWidth,\n    height: anchorHeight,\n    x: anchorX,\n    y: anchorY\n  } = anchorElement.getBoundingClientRect()\n  const { width, height } = dimensions\n\n  let x: number, y: number\n\n  if (position === 'up') {\n    y = anchorY - height - distance\n\n    switch (alignment) {\n      case 'start':\n        x = anchorX\n        break\n      case 'center':\n        x = anchorX + anchorWidth / 2 - width / 2\n        break\n      case 'end':\n        x = anchorX + anchorWidth - width\n        break\n      default:\n        break\n    }\n  }\n\n  if (position === 'down') {\n    y = anchorY + anchorHeight + distance\n\n    switch (alignment) {\n      case 'start':\n        x = anchorX\n        break\n      case 'center':\n        x = anchorX + anchorWidth / 2 - width / 2\n        break\n      case 'end':\n        x = anchorX + anchorWidth - width\n        break\n      default:\n        break\n    }\n  }\n\n  if (position === 'left') {\n    x = anchorX - width - distance\n\n    switch (alignment) {\n      case 'start':\n        y = anchorY\n        break\n      case 'center':\n        y = anchorY + anchorHeight / 2 - height / 2\n        break\n      case 'end':\n        y = anchorY + anchorHeight - height\n        break\n      default:\n        break\n    }\n  }\n\n  if (position === 'right') {\n    x = anchorX + anchorWidth + distance\n\n    switch (alignment) {\n      case 'start':\n        y = anchorY\n        break\n      case 'center':\n        y = anchorY + anchorHeight / 2 - height / 2\n        break\n      case 'end':\n        y = anchorY + anchorHeight - height\n        break\n      default:\n        break\n    }\n  }\n\n  return { x, y }\n}\n\nconst getValidPositioning = (\n  dimensions: ContentDimensions,\n  anchor: string,\n  anchorRef: AnchorRef,\n  distance: number,\n  position: PopupPosition,\n  alignment: PopupAlignment,\n  offsets: PopupOffset\n) => {\n  const { width, height } = dimensions\n  const viewportWidth = getViewportWidth()\n  const viewportHeight = getViewportHeight()\n  let contentPosition: PopupContentPosition\n\n  if (!!anchor || !!anchorRef) {\n    contentPosition = getPositioningWithAnchor(\n      dimensions,\n      anchor,\n      anchorRef,\n      distance,\n      position,\n      alignment\n    )\n  } else {\n    contentPosition = getPositioningWithoutAnchor(\n      dimensions,\n      position,\n      alignment\n    )\n  }\n\n  if (offsets) {\n    const xOffset = offsets.x || 0\n    const yOffset = offsets.y || 0\n\n    contentPosition.x = contentPosition.x + xOffset\n    contentPosition.y = contentPosition.y + yOffset\n  }\n\n  const leftEdge = EDGE_PADDING\n  const topEdge = EDGE_PADDING\n  const rightEdge = viewportWidth - width\n  const bottomEdge = viewportHeight - height\n\n  if (contentPosition.x <= leftEdge) contentPosition.x = leftEdge\n  if (contentPosition.y <= topEdge) contentPosition.y = topEdge\n  if (contentPosition.x >= rightEdge) contentPosition.x = rightEdge\n  if (contentPosition.y >= bottomEdge) contentPosition.y = bottomEdge\n\n  return contentPosition\n}\n\nconst Popup: React.FC<PopupProps> = ({\n  anchor,\n  anchorRef,\n  children,\n  contentClassName,\n  position,\n  alignment,\n  transparent,\n  distance,\n  offsets,\n  isVisible,\n  hideArrow,\n  overlayCloseOnClick,\n  onRequestClose\n}) => {\n  const [\n    popupContentPosition,\n    setPopupContentPosition\n  ] = useState<PopupContentPosition>({\n    x: 0,\n    y: 0\n  })\n\n  const handleClickOverlay = useMouseDown(() => {\n    if (overlayCloseOnClick) onRequestClose()\n  })\n\n  const handleKeyUp = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === 'Escape' && isVisible) onRequestClose()\n    },\n    [isVisible, onRequestClose]\n  )\n\n  useEffect(() => {\n    document.addEventListener('keyup', handleKeyUp)\n\n    return () => {\n      document.removeEventListener('keyup', handleKeyUp)\n    }\n  }, [isVisible, handleKeyUp])\n\n  const render = () => (\n    <div className='fixed top-0 left-0 w-full h-full z-2'>\n      <div\n        className={\n          transparent\n            ? 'w-full h-full absolute top-0 left-0 z-0'\n            : 'w-full h-full absolute top-0 left-0 z-0 bg-blue-800 opacity-50'\n        }\n        onMouseDown={handleClickOverlay}\n      />\n      <Content\n        className={contentClassName}\n        x={popupContentPosition.x}\n        y={popupContentPosition.y}\n        position={position}\n        alignment={alignment}\n        hideArrow={(!anchorRef && !anchor) || hideArrow}\n        onLayoutUpdate={(dimensions) =>\n          setPopupContentPosition(\n            getValidPositioning(\n              dimensions,\n              anchor,\n              anchorRef,\n              distance,\n              position,\n              alignment,\n              offsets\n            )\n          )\n        }\n      >\n        {children}\n      </Content>\n    </div>\n  )\n\n  if (!isVisible) return null\n\n  // return createPortal(render(), document.getElementById('docmaker-modal-root'))\n  return render()\n}\n\nPopup.defaultProps = {\n  position: 'center',\n  alignment: 'center',\n  transparent: false,\n  distance: 10,\n  overlayCloseOnClick: true,\n  hideArrow: false,\n  isVisible: false\n}\n\nexport default Popup\n","import { ImageDimensions, getImageSizeAsync, nil } from '../../../core/utils'\nimport React, {\n  ChangeEvent,\n  FC,\n  MutableRefObject,\n  useCallback,\n  useMemo,\n  useState\n} from 'react'\n\nimport { BiLink } from '@react-icons/all-files/bi/BiLink'\nimport Button from '../../button'\nimport Icon from '../../icon'\nimport Popup from '../../popup'\n\nexport type ImageProps = {\n  url?: string\n  label?: string\n  dimensions: ImageDimensions\n}\n\ntype ImagePopupProps = {\n  anchorRef: MutableRefObject<Element>\n  isVisible: boolean\n  onRequestClose: Fn\n  onSubmitEditing?: (value: ImageProps) => void\n}\n\nconst ImagePopup: FC<ImagePopupProps> = ({\n  anchorRef,\n  isVisible,\n  onRequestClose,\n  onSubmitEditing\n}) => {\n  const [imageState, setImageState] = useState('')\n  const [scaleState, setScaleState] = useState('100')\n  const [imageDimensions, setImageDimensions] = useState<ImageDimensions>()\n\n  const decimalScale = useMemo(() => {\n    const value = parseFloat(scaleState)\n    const normalized = isNaN(value) || value < 1 ? 1 : value\n    return normalized / 100\n  }, [scaleState])\n\n  const handleChangeImageUrl = useCallback(\n    (e: ChangeEvent<HTMLInputElement>) => {\n      setImageState(e.target.value)\n    },\n    []\n  )\n\n  const handleChangeScale = useCallback((e: ChangeEvent<HTMLInputElement>) => {\n    setScaleState(e.target.value)\n  }, [])\n\n  const handleBlurImageInput = useCallback(async () => {\n    if (!imageState?.length) {\n      setImageDimensions(null)\n      return\n    }\n\n    try {\n      const dimensions = await getImageSizeAsync(imageState)\n      setImageDimensions(dimensions)\n    } catch (error) {\n      setImageDimensions(null)\n    }\n  }, [imageState])\n\n  const handleRequestClose = useCallback(() => {\n    setImageState('')\n    setScaleState('100')\n    setImageDimensions(null)\n    onRequestClose?.()\n  }, [onRequestClose])\n\n  const handlePressSubmit = useCallback(() => {\n    onSubmitEditing?.({\n      url: imageState,\n      dimensions: {\n        width: imageDimensions.width * decimalScale,\n        height: imageDimensions.height * decimalScale\n      }\n    })\n    handleRequestClose()\n  }, [\n    decimalScale,\n    handleRequestClose,\n    imageDimensions,\n    imageState,\n    onSubmitEditing\n  ])\n\n  return (\n    <Popup\n      position='down'\n      alignment='start'\n      isVisible={isVisible}\n      onRequestClose={handleRequestClose}\n      anchorRef={anchorRef}\n      transparent\n      hideArrow\n      overlayCloseOnClick\n      contentClassName='rounded-default'\n    >\n      <div className='rounded-default p-8 w-296 bg-white border border-gray-300 overflow-hidden text-gray-500'>\n        <div className='flex items-center justify-between space-x-4 mb-8'>\n          <div className='h-32 flex-1 overflow-hidden rounded-default border border-gray-200 flex items-center justify-start'>\n            <div className='flex s-32 rounded-default rounded-r-none rounded-b-none bg-gray-200 text-gray-500 items-center justify-center font-semibold'>\n              <Icon>\n                <BiLink />\n              </Icon>\n            </div>\n            <input\n              className='border-none h-full px-6 bg-transparent font-medium flex-1 min-w-0'\n              type='text'\n              placeholder='https://www...'\n              value={imageState}\n              onChange={handleChangeImageUrl}\n              onBlur={handleBlurImageInput}\n            />\n          </div>\n          <div className='h-32 overflow-hidden rounded-default border border-gray-200 flex items-center justify-start'>\n            <input\n              maxLength={3}\n              className='border-none h-full w-40 px-6 bg-transparent font-medium m-0'\n              placeholder='0'\n              value={scaleState}\n              onChange={handleChangeScale}\n            />\n            <div className='flex s-32 bg-transparent text-gray-300 items-center justify-center font-semibold'>\n              %\n            </div>\n          </div>\n        </div>\n        <div className='flex justify-end'>\n          <Button\n            disabled={nil(imageDimensions)}\n            className='h-32'\n            onPress={handlePressSubmit}\n          >\n            Insert\n          </Button>\n        </div>\n      </div>\n    </Popup>\n  )\n}\n\nexport default ImagePopup\n","import React, {\n  FC,\n  memo,\n  MutableRefObject,\n  useCallback,\n  useState,\n  ChangeEvent\n} from 'react'\nimport Popup from '../../popup'\nimport css from './style.module.css'\nimport classnames from 'classnames'\nimport { areEqualColors, isHexColor } from '../../../core/utils'\nimport { useMouseDown } from '../../../core/hooks'\nimport { PRESET_COLORS } from '../../../core/constants'\n\ntype ColorPopupProps = {\n  anchorRef: MutableRefObject<Element>\n  isVisible: boolean\n  value?: string\n  onChangeColorOption?: (value?: string, focus?: boolean) => void\n  onRequestClose: Fn\n}\n\ntype ColorBoxProps = {\n  active?: boolean\n  color: string\n  onPress?: (value: string) => void\n}\n\nconst BaseColorBox: FC<ColorBoxProps> = ({ active, color, onPress }) => {\n  const handlePress = useMouseDown(() => {\n    onPress?.(color)\n  })\n\n  return (\n    <div\n      style={{ color }}\n      onMouseDown={handlePress}\n      title={color}\n      className={classnames(\n        's-32 rounded-default bg-current cursor-pointer transition-shadow duration-250',\n        css['color-box'],\n        { [css.active]: active }\n      )}\n    />\n  )\n}\n\nconst ColorBox = memo(BaseColorBox)\n\nconst ColorPopup: FC<ColorPopupProps> = ({\n  anchorRef,\n  isVisible,\n  value,\n  onChangeColorOption,\n  onRequestClose\n}) => {\n  const [colorState, setColorState] = useState('')\n\n  const handlePressColorOption = useCallback(\n    (option: string) => {\n      if (!isHexColor(option)) {\n        return\n      }\n\n      const selectedColor = areEqualColors(value, option) ? null : option\n\n      setColorState(selectedColor?.replaceAll('#', ''))\n      onChangeColorOption?.(selectedColor)\n      onRequestClose?.()\n    },\n    [onChangeColorOption, onRequestClose, value]\n  )\n\n  const handleChangeInput = useCallback(\n    (e: ChangeEvent<HTMLInputElement>) => {\n      const inputValue = e.target.value\n      const parsedColor = inputValue?.length\n        ? `#${inputValue.replace('#', '')}`\n        : null\n\n      setColorState(e.target.value)\n\n      if (isHexColor(parsedColor)) {\n        onChangeColorOption?.(parsedColor, false)\n      }\n    },\n    [onChangeColorOption]\n  )\n\n  return (\n    <Popup\n      position='down'\n      alignment='start'\n      isVisible={isVisible}\n      onRequestClose={onRequestClose}\n      anchorRef={anchorRef}\n      transparent\n      hideArrow\n      overlayCloseOnClick\n      contentClassName='rounded-default'\n    >\n      <div className='rounded-default grid grid-cols-7 gap-6 p-8 bg-white border border-gray-300 overflow-hidden text-gray-500'>\n        {PRESET_COLORS.map((o) => (\n          <ColorBox\n            color={o}\n            key={o}\n            onPress={handlePressColorOption}\n            active={areEqualColors(value, o)}\n          />\n        ))}\n        <div className='h-32 col-span-4 overflow-hidden rounded-default border border-gray-200 flex items-center justify-start'>\n          <div className='flex s-32 rounded-default rounded-r-none rounded-b-none bg-gray-200 text-gray-500 items-center justify-center font-semibold'>\n            #\n          </div>\n          <input\n            maxLength={6}\n            className={classnames(\n              'border-none h-full px-6 bg-transparent font-medium',\n              css.input\n            )}\n            type='text'\n            placeholder={value?.replace('#', '')}\n            value={colorState}\n            onChange={handleChangeInput}\n          />\n        </div>\n      </div>\n    </Popup>\n  )\n}\n\nexport default ColorPopup\n","import React, {\n  Children,\n  cloneElement,\n  FC,\n  PropsWithChildren,\n  ReactElement\n} from 'react'\nimport classnames from 'classnames'\n\ntype FieldProps = PropsWithChildren<{\n  label?: string\n  className?: string\n}>\n\nconst Field: FC<FieldProps> = ({ className, children, label }) => {\n  return (\n    <div className={className}>\n      {!!label?.length && (\n        <label className='text-blue-500 block mb-4 text-subhead font-medium'>\n          {label}\n        </label>\n      )}\n      {Children.map(children, (child: ReactElement) =>\n        cloneElement(child, {\n          className: classnames(\n            child.props.className,\n            'w-full appearance-none border border-gray-200 rounded-default h-32 px-8 transition:colors transition:shadow duration-250 focus:border-blue-500 focus:shadow-outline'\n          )\n        })\n      )}\n    </div>\n  )\n}\n\nexport default Field\n","import React, {\n  ChangeEvent,\n  FC,\n  MutableRefObject,\n  useCallback,\n  useMemo,\n  useState\n} from 'react'\nimport { useEditor, useOrphanNodes } from '../../../core/hooks'\nimport {\n  EditableAttributes,\n  EditableElementType,\n  EditableRefAttributes,\n  getMatchingNodes\n} from '../../../core/tools'\nimport Button from '../../button'\nimport Field from '../../field'\nimport Popup from '../../popup'\n\ntype ConditionPopupProps = {\n  anchorRef: MutableRefObject<Element>\n  isVisible: boolean\n  onRequestClose: Fn\n  onSubmitEditing?: (value: EditableRefAttributes) => void\n}\n\nconst ConditionPopup: FC<ConditionPopupProps> = ({\n  anchorRef,\n  isVisible,\n  onRequestClose,\n  onSubmitEditing\n}) => {\n  const editor = useEditor()\n  const [orphanNodes] = useOrphanNodes()\n  const editableNodes = getMatchingNodes(\n    editor,\n    (o) =>\n      o.type === 'editable' &&\n      !(o.valueRef as string)?.length &&\n      ['options', 'radio'].includes(o.dataType as string)\n  )\n    .concat(orphanNodes)\n    .map((o) => o as EditableElementType<EditableAttributes>)\n\n  const [parent, setParent] = useState('')\n  const [value, setValue] = useState('')\n  const options = useMemo(\n    () => editableNodes.find((o) => o.id === parent)?.options || [],\n    [editableNodes, parent]\n  )\n\n  const isValid = !!parent?.length && !!value?.length\n\n  const handleChangeParent = useCallback(\n    (e: ChangeEvent<HTMLSelectElement>) => {\n      const selected = e.target.value\n\n      if (selected === parent) {\n        return\n      }\n\n      setParent(selected)\n      setValue('')\n    },\n    [parent]\n  )\n\n  const handleChangeValue = useCallback(\n    (e: ChangeEvent<HTMLSelectElement>) => {\n      const selected = e.target.value\n\n      if (selected === value) {\n        return\n      }\n\n      setValue(selected)\n    },\n    [value]\n  )\n\n  const handleRequestClose = useCallback(() => {\n    setParent('')\n    setValue('')\n    onRequestClose?.()\n  }, [onRequestClose])\n\n  const handlePressSubmit = useCallback(() => {\n    onSubmitEditing?.({\n      parent,\n      value\n    })\n    handleRequestClose()\n  }, [handleRequestClose, onSubmitEditing, parent, value])\n\n  return (\n    <Popup\n      position='down'\n      alignment='start'\n      isVisible={isVisible}\n      onRequestClose={handleRequestClose}\n      anchorRef={anchorRef}\n      transparent\n      hideArrow\n      overlayCloseOnClick\n      contentClassName='rounded-default'\n    >\n      <div className='rounded-default p-8 space-y-8 w-320 bg-white border border-gray-300 overflow-hidden text-gray-500'>\n        <Field label='Only show when...'>\n          <select value={parent} onChange={handleChangeParent}>\n            <option hidden value=''>\n              Choose one\n            </option>\n            {editableNodes.map((o) => (\n              <option key={o.id} value={o.id}>\n                {o.defaultValue}({o.label})\n              </option>\n            ))}\n          </select>\n        </Field>\n        <Field label='equals...'>\n          <select value={value} onChange={handleChangeValue}>\n            <option hidden value=''>\n              Choose one\n            </option>\n            {options.map((o) => (\n              <option key={o.id} value={o.id}>\n                {o.label}\n              </option>\n            ))}\n          </select>\n        </Field>\n        <div className='flex justify-end'>\n          <Button\n            disabled={!isValid}\n            className='h-32'\n            onPress={handlePressSubmit}\n          >\n            Add condition\n          </Button>\n        </div>\n      </div>\n    </Popup>\n  )\n}\n\nexport default ConditionPopup\n","import React, { MouseEvent, FC, memo } from 'react'\nimport classnames from 'classnames'\n\ntype SegmentedControlProps = {\n  className?: string\n  value: number\n  options: Array<string>\n  onChangeValue: (value: number) => void\n}\n\nconst BaseSegmentedControl: FC<SegmentedControlProps> = ({\n  className,\n  value,\n  options,\n  onChangeValue\n}) => {\n  const handlePressOption = (e: MouseEvent, index: number) => {\n    e.preventDefault()\n    onChangeValue?.(index)\n  }\n\n  return (\n    <div\n      className={classnames(\n        'bg-gray-100 rounded-full p-4 w-296 h-40 flex items-center relative',\n        className\n      )}\n    >\n      <div\n        className='absolute bg-gray-500 rounded-full z-0 top-4 h-32 transition-all duration-500'\n        style={{ width: 144, left: 144 * value + 4 }}\n      />\n      {options.map((o, i) => (\n        <div\n          className={classnames(\n            'font-medium flex-1 flex items-center justify-center relative z-1 cursor-pointer transition-colors duration-500',\n            {\n              'text-gray-500 hover:text-gray-700': value !== i,\n              'text-white': value === i\n            }\n          )}\n          key={i}\n          onMouseDown={(e) => handlePressOption(e, i)}\n        >\n          {o}\n        </div>\n      ))}\n    </div>\n  )\n}\n\nconst SegmentedControl = memo(BaseSegmentedControl)\n\nexport default SegmentedControl\n","import {\n  EditableAttributes,\n  EditableElementType,\n  getEditableAttributes,\n  getEditableAttributesValidity,\n  getMatchingNodes\n} from '../../../../core/tools'\nimport React, { ChangeEvent, FC, useCallback, useMemo, useState } from 'react'\n\nimport Button from '../../../button'\nimport Field from '../../../field'\nimport { useEditor } from '../../../../core/hooks'\n\ntype EditableCopyExistingProps = {\n  onSubmit?: (attributes: EditableAttributes) => void\n}\n\nconst EditableCopyExisting: FC<EditableCopyExistingProps> = ({ onSubmit }) => {\n  const editor = useEditor()\n  const editableNodes = useMemo(\n    () =>\n      getMatchingNodes(\n        editor,\n        (o) => o.type === 'editable' && !(o.valueRef as string)?.length\n      ).map((o) => o as EditableElementType<EditableAttributes>),\n    [editor]\n  )\n\n  const [valueRef, setValueRef] = useState('')\n  const [defaultValue, setDefaultValue] = useState('')\n  const dataType = useMemo(\n    () => editableNodes?.find((o) => o.id === valueRef)?.dataType,\n    [editableNodes, valueRef]\n  )\n\n  const isValid = useMemo(\n    () =>\n      getEditableAttributesValidity(\n        { valueRef, defaultValue, dataType },\n        false,\n        true\n      ),\n    [dataType, defaultValue, valueRef]\n  )\n\n  const handleChangeValueRef = useCallback(\n    (e: ChangeEvent<HTMLSelectElement>) => {\n      const value = e.target.value\n\n      if (value === valueRef) {\n        return\n      }\n\n      setValueRef(value)\n      setDefaultValue(\n        editableNodes.find((o) => o.id === value)?.defaultValue || ''\n      )\n    },\n    [editableNodes, valueRef]\n  )\n\n  const handleChangeDefaultValue = useCallback(\n    (e: ChangeEvent<HTMLInputElement>) => {\n      setDefaultValue(e.target.value)\n    },\n    []\n  )\n\n  const handlePressSubmit = useCallback(() => {\n    const data = getEditableAttributes({ valueRef, defaultValue, dataType })\n\n    onSubmit?.(data)\n  }, [dataType, defaultValue, onSubmit, valueRef])\n\n  return (\n    <div>\n      <Field label='Copy from' className='mb-18'>\n        <select value={valueRef} onChange={handleChangeValueRef}>\n          <option hidden value=''>\n            Choose one\n          </option>\n          {editableNodes.map((o) => (\n            <option key={o.id} value={o.id}>\n              {o.defaultValue}({o.label})\n            </option>\n          ))}\n        </select>\n      </Field>\n      <Field label='Default value' className='mb-18'>\n        <input\n          value={defaultValue}\n          onChange={handleChangeDefaultValue}\n          placeholder='Default'\n        />\n      </Field>\n      <div className='flex justify-end pt-24'>\n        <Button\n          disabled={!isValid}\n          className='h-32'\n          onPress={handlePressSubmit}\n        >\n          Insert\n        </Button>\n      </div>\n    </div>\n  )\n}\n\nexport default EditableCopyExisting\n","import React, { FC, memo } from 'react'\nimport ReactSwitch from 'react-switch'\n\ntype SwitchProps = {\n  className?: string\n  value: boolean\n  onChangeValue: (value: boolean) => void\n}\n\nconst BaseSwitch: FC<SwitchProps> = ({ className, value, onChangeValue }) => {\n  return (\n    <ReactSwitch\n      checked={value}\n      className={className}\n      onChange={onChangeValue}\n      offColor='#ADC5FA'\n      onColor='#326FF3'\n      checkedIcon={false}\n      uncheckedIcon={false}\n      handleDiameter={18}\n      height={22}\n      width={44}\n      activeBoxShadow='0 0 0 4px rgba(103, 126, 138, 0.125)'\n    />\n  )\n}\n\nconst Switch = memo(BaseSwitch)\n\nexport default Switch\n","import React, {\n  ChangeEvent,\n  FC,\n  useCallback,\n  useMemo,\n  useRef,\n  useState,\n  KeyboardEvent\n} from 'react'\nimport Button from '../../../button'\nimport Field from '../../../field'\nimport Switch from '../../../switch'\nimport { FaRegTrashAlt } from '@react-icons/all-files/fa/FaRegTrashAlt'\nimport { AiFillPlusCircle } from '@react-icons/all-files/ai/AiFillPlusCircle'\nimport Icon from '../../../icon'\nimport {\n  EditableAttributes,\n  EditableDataType,\n  EditableOption,\n  getEditableAttributes,\n  getEditableAttributesValidity\n} from '../../../../core/tools'\nimport {\n  DATE_FORMATS,\n  EDITABLE_DATA_TYPES,\n  TIME_FORMATS\n} from '../../../../core/constants'\nimport { formatDate, generateUUID } from '../../../../core/utils'\n\ntype EditableCreateNewProps = {\n  onSubmit?: (attributes: EditableAttributes, isOrphan?: boolean) => void\n}\n\nconst EditableCreateNew: FC<EditableCreateNewProps> = ({ onSubmit }) => {\n  const now = useRef(new Date()).current\n  const dataTypeOptions = useRef(Object.entries(EDITABLE_DATA_TYPES)).current\n  const dateFormatOptions = useRef(DATE_FORMATS).current\n  const timeFormatOptions = useRef(TIME_FORMATS).current\n\n  const [dataType, setDataType] = useState<EditableDataType>(\n    '' as EditableDataType\n  )\n  const [defaultValue, setDefaultValue] = useState('')\n  const [dateTimeFormat, setDateTimeFormat] = useState('')\n  const [label, setLabel] = useState('')\n  const [multiline, setMultiline] = useState(false)\n  const [options, setOptions] = useState<Array<EditableOption>>([])\n  const [editingOption, setEditingOption] = useState('')\n  const [showTip, setShowTip] = useState(false)\n  const [isOrphan, setIsOrphan] = useState(false)\n  const [tip, setTip] = useState('')\n\n  const isValid = useMemo(\n    () =>\n      getEditableAttributesValidity(\n        {\n          dataType,\n          dateTimeFormat,\n          defaultValue,\n          label,\n          options,\n          tip\n        },\n        showTip\n      ),\n    [dataType, dateTimeFormat, defaultValue, label, options, showTip, tip]\n  )\n\n  const handlePressDeleteOption = useCallback(\n    (id: string) => {\n      const eventualValue = [...options]\n      const index = eventualValue.findIndex((o) => o.id === id)\n\n      if (~index) {\n        eventualValue.splice(index, 1)\n        setOptions(eventualValue)\n      }\n    },\n    [options]\n  )\n\n  const handlePressAddOption = useCallback(() => {\n    const label = editingOption?.trim()\n\n    if (!label?.length) {\n      return\n    }\n\n    const id = generateUUID()\n\n    setOptions((groundValue) => [...groundValue, { id, label }])\n    setEditingOption('')\n  }, [editingOption])\n\n  const handleEditingOptionKeydown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key?.toLowerCase() === 'enter') {\n        e.preventDefault()\n        handlePressAddOption()\n      }\n    },\n    [handlePressAddOption]\n  )\n\n  const handlePressSubmit = useCallback(() => {\n    const data = getEditableAttributes(\n      {\n        dataType,\n        dateTimeFormat,\n        multiline,\n        defaultValue,\n        label,\n        options,\n        tip\n      },\n      showTip\n    )\n\n    onSubmit?.(data, isOrphan)\n  }, [\n    dataType,\n    dateTimeFormat,\n    defaultValue,\n    isOrphan,\n    label,\n    multiline,\n    onSubmit,\n    options,\n    showTip,\n    tip\n  ])\n\n  const handleChangeDataType = useCallback(\n    (e: ChangeEvent<HTMLSelectElement>) => {\n      const value = e.target.value as EditableDataType\n\n      if (value === dataType) {\n        return\n      }\n\n      setDataType(value)\n\n      if (value === 'date' || value === 'time') {\n        setDateTimeFormat('')\n      }\n    },\n    [dataType]\n  )\n\n  const handleChangeDateTimeFormat = useCallback(\n    (e: ChangeEvent<HTMLSelectElement>) => {\n      setDateTimeFormat(e.target.value)\n    },\n    []\n  )\n\n  const handleChangeEditingOption = useCallback(\n    (e: ChangeEvent<HTMLInputElement>) => {\n      setEditingOption(e.target.value)\n    },\n    []\n  )\n\n  const handleChangeLabel = useCallback((e: ChangeEvent<HTMLInputElement>) => {\n    setLabel(e.target.value)\n  }, [])\n\n  const handleChangeDefaultValue = useCallback(\n    (e: ChangeEvent<HTMLInputElement>) => {\n      setDefaultValue(e.target.value)\n    },\n    []\n  )\n\n  const handleChangeTip = useCallback((e: ChangeEvent<HTMLInputElement>) => {\n    setTip(e.target.value)\n  }, [])\n\n  return (\n    <div>\n      <div className='flex items-end space-x-12 mb-18'>\n        <Field label='Type' className='flex-1'>\n          <select value={dataType} onChange={handleChangeDataType}>\n            <option hidden value=''>\n              Choose one\n            </option>\n            {dataTypeOptions.map(([value, label]) => (\n              <option key={value} value={value}>\n                {label}\n              </option>\n            ))}\n          </select>\n        </Field>\n        {dataType === 'text' && (\n          <div className='flex flex-1 justify-start items-center space-x-8 pb-6'>\n            <div>Multiline</div>\n            <Switch value={multiline} onChangeValue={setMultiline} />\n          </div>\n        )}\n        {dataType === 'date' && (\n          <Field label='Date format'>\n            <select\n              value={dateTimeFormat}\n              onChange={handleChangeDateTimeFormat}\n            >\n              <option hidden value=''>\n                Choose a format\n              </option>\n              {dateFormatOptions.map((o) => (\n                <option key={o} value={o}>\n                  {formatDate(now, o)}\n                </option>\n              ))}\n            </select>\n          </Field>\n        )}\n        {dataType === 'time' && (\n          <Field label='Time format'>\n            <select\n              value={dateTimeFormat}\n              onChange={handleChangeDateTimeFormat}\n            >\n              <option hidden value=''>\n                Choose a format\n              </option>\n              {timeFormatOptions.map((o) => (\n                <option key={o} value={o}>\n                  {formatDate(now, o)}\n                </option>\n              ))}\n            </select>\n          </Field>\n        )}\n      </div>\n      {['radio', 'options'].includes(dataType) && (\n        <div className='mb-18'>\n          <div className='text-blue-500 block mb-4 text-subhead font-medium'>\n            Options\n          </div>\n          <div className='space-y-6'>\n            {options?.map((o) => (\n              <div\n                key={o.id}\n                onClick={() => handlePressDeleteOption(o.id)}\n                className='flex items-center justify-between px-8 h-32 w-full border border-gray-200 bg-gray-100 rounded-default'\n              >\n                <span className='text-gray-500'>{o.label}</span>\n                <Icon className='cursor-pointer text-gray-500 transition-colors duration-250'>\n                  <FaRegTrashAlt />\n                </Icon>\n              </div>\n            ))}\n            <div className='flex items-center justify-between px-8 h-32 w-full border border-gray-200 rounded-default transition:colors transition:shadow duration-250 focus-within:shadow-outline focus-within:border-blue-500'>\n              <input\n                value={editingOption}\n                className='border-none h-full w-full bg-transparent m-0'\n                placeholder='+ Add an option'\n                onChange={handleChangeEditingOption}\n                onKeyDown={handleEditingOptionKeydown}\n              />\n              <Icon\n                onPress={handlePressAddOption}\n                className='cursor-pointer text-blue-500 transition-colors duration-250 hover:text-blue-600'\n              >\n                <AiFillPlusCircle />\n              </Icon>\n            </div>\n          </div>\n        </div>\n      )}\n      <Field label='Label' className='mb-18'>\n        <input\n          value={label}\n          onChange={handleChangeLabel}\n          placeholder='Question label'\n        />\n      </Field>\n      <Field label='Default value' className='mb-18'>\n        <input\n          value={defaultValue}\n          onChange={handleChangeDefaultValue}\n          placeholder='Default'\n        />\n      </Field>\n      <div className='flex flex-1 justify-between items-center mb-18'>\n        <div>Show description</div>\n        <Switch value={showTip} onChangeValue={setShowTip} />\n      </div>\n      {showTip && (\n        <Field label='Description' className='mb-18'>\n          <input\n            value={tip}\n            onChange={handleChangeTip}\n            placeholder='Lorem ipsum...'\n          />\n        </Field>\n      )}\n      <div className='flex flex-1 justify-between items-center mb-18'>\n        <div>Save in Icebox</div>\n        <Switch value={isOrphan} onChangeValue={setIsOrphan} />\n      </div>\n      <div className='flex justify-end pt-24'>\n        <Button\n          disabled={!isValid}\n          onPress={handlePressSubmit}\n          className='h-32'\n        >\n          Insert\n        </Button>\n      </div>\n    </div>\n  )\n}\n\nexport default EditableCreateNew\n","import React, { FC, useCallback, useState } from 'react'\nimport { EditableAttributes } from '../../../core/tools'\nimport Popup from '../../popup'\nimport SegmentedControl from '../../segmented-control'\nimport EditableCopyExisting from './copy-existing'\nimport EditableCreateNew from './create-new'\n\ntype EditablePopupProps = {\n  isVisible: boolean\n  onRequestClose: Fn\n  onSubmit: (attributes: EditableAttributes, isOrphan?: boolean) => void\n}\n\nconst EditablePopupProps: FC<EditablePopupProps> = ({\n  isVisible,\n  onRequestClose,\n  onSubmit\n}) => {\n  const [segment, setSegment] = useState(0)\n\n  const handleSubmit = useCallback(\n    (attributes: EditableAttributes, isOrphan = false) => {\n      onSubmit?.(attributes, isOrphan)\n      onRequestClose?.()\n      setSegment(0)\n    },\n    [onRequestClose, onSubmit]\n  )\n\n  return (\n    <Popup\n      position='center'\n      alignment='center'\n      isVisible={isVisible}\n      onRequestClose={onRequestClose}\n      hideArrow\n      overlayCloseOnClick\n      contentClassName='rounded-default'\n    >\n      <div className='rounded-default w-480 py-12 px-16 bg-white border border-gray-300 overflow-hidden'>\n        <div className='flex items-center justify-center mb-28'>\n          <SegmentedControl\n            value={segment}\n            onChangeValue={setSegment}\n            options={['Create new', 'Copy existing']}\n          />\n        </div>\n        {segment === 0 && <EditableCreateNew onSubmit={handleSubmit} />}\n        {segment === 1 && <EditableCopyExisting onSubmit={handleSubmit} />}\n      </div>\n    </Popup>\n  )\n}\n\nexport default EditablePopupProps\n","import { ImageDimensions, notNil, parseNumber } from '../../../core/utils'\nimport React, {\n  ChangeEvent,\n  FC,\n  MutableRefObject,\n  useCallback,\n  useState\n} from 'react'\n\nimport Button from '../../button'\nimport Field from '../../field'\nimport Icon from '../../icon'\nimport Popup from '../../popup'\nimport { TiTimes } from '@react-icons/all-files/ti/TiTimes'\n\ntype ImageSizePopupProps = {\n  anchorRef: MutableRefObject<Element>\n  isVisible: boolean\n  onRequestClose: Fn\n  onSubmitEditing?: (value: ImageDimensions, label?: string) => void\n}\n\nconst ImageSizePopup: FC<ImageSizePopupProps> = ({\n  anchorRef,\n  isVisible,\n  onRequestClose,\n  onSubmitEditing\n}) => {\n  const [width, setWidth] = useState(100)\n  const [height, setHeight] = useState(100)\n  const [label, setLabel] = useState('')\n\n  const isValid =\n    notNil(width) && notNil(height) && !!label?.length && width * height > 0\n\n  const handleChangeWidth = useCallback((e: ChangeEvent<HTMLInputElement>) => {\n    setWidth(parseNumber(e.target.value))\n  }, [])\n\n  const handleChangeHeight = useCallback((e: ChangeEvent<HTMLInputElement>) => {\n    setHeight(parseNumber(e.target.value))\n  }, [])\n\n  const handleChangeLabel = useCallback((e: ChangeEvent<HTMLInputElement>) => {\n    setLabel(e.target.value)\n  }, [])\n\n  const handleRequestClose = useCallback(() => {\n    setWidth(100)\n    setHeight(100)\n    onRequestClose?.()\n  }, [onRequestClose])\n\n  const handlePressSubmit = useCallback(() => {\n    onSubmitEditing?.(\n      {\n        width,\n        height\n      },\n      label\n    )\n    handleRequestClose()\n  }, [handleRequestClose, height, label, onSubmitEditing, width])\n\n  return (\n    <Popup\n      position='down'\n      alignment='start'\n      isVisible={isVisible}\n      onRequestClose={handleRequestClose}\n      anchorRef={anchorRef}\n      transparent\n      hideArrow\n      overlayCloseOnClick\n      contentClassName='rounded-default'\n    >\n      <div className='rounded-default p-8 bg-white border border-gray-300 overflow-hidden text-gray-500'>\n        <div>\n          <Field label='Label' className='mb-8'>\n            <input\n              value={label}\n              onChange={handleChangeLabel}\n              placeholder='Image upload label'\n            />\n          </Field>\n        </div>\n        <span className='text-blue-500 block mb-4 text-subhead font-medium'>\n          Dimensions\n        </span>\n        <div className='flex items-center justify-between space-x-4 mb-8'>\n          <div className='h-32 overflow-hidden rounded-default border border-gray-200 flex items-center justify-start'>\n            <input\n              className='border-none h-full w-40 px-6 bg-transparent font-medium m-0'\n              placeholder='0'\n              value={width}\n              onChange={handleChangeWidth}\n            />\n            <div className='flex s-32 bg-transparent text-gray-300 items-center justify-center text-subhead font-semibold'>\n              PX\n            </div>\n          </div>\n          <Icon>\n            <TiTimes />\n          </Icon>\n          <div className='h-32 overflow-hidden rounded-default border border-gray-200 flex items-center justify-start'>\n            <input\n              className='border-none h-full w-40 px-6 bg-transparent font-medium m-0'\n              placeholder='0'\n              value={height}\n              onChange={handleChangeHeight}\n            />\n            <div className='flex s-32 bg-transparent text-gray-300 items-center justify-center text-subhead font-semibold'>\n              PX\n            </div>\n          </div>\n        </div>\n        <div className='flex justify-end'>\n          <Button\n            disabled={!isValid}\n            className='h-32'\n            onPress={handlePressSubmit}\n          >\n            Insert\n          </Button>\n        </div>\n      </div>\n    </Popup>\n  )\n}\n\nexport default ImageSizePopup\n","import React, { FC, MutableRefObject, useCallback } from 'react'\nimport { FiInbox } from '@react-icons/all-files/fi/FiInbox'\nimport { useOrphanNodes } from '../../../core/hooks'\nimport Icon from '../../icon'\nimport Popup from '../../popup'\nimport { FaRegTrashAlt } from '@react-icons/all-files/fa/FaRegTrashAlt'\n\ntype OrphanNodesPopupProps = {\n  anchorRef: MutableRefObject<Element>\n  isVisible: boolean\n  onRequestClose: Fn\n}\n\nconst OrphanNodesPopup: FC<OrphanNodesPopupProps> = ({\n  anchorRef,\n  isVisible,\n  onRequestClose\n}) => {\n  const [orphanNodes, setOrphanNodes] = useOrphanNodes()\n\n  const handlePressDelete = useCallback(\n    (id: string) => {\n      const eventualValue = [...orphanNodes]\n      const index = eventualValue.findIndex((o) => o.id === id)\n\n      if (!~index) {\n        return\n      }\n\n      eventualValue.splice(index, 1)\n      setOrphanNodes(eventualValue)\n    },\n    [orphanNodes, setOrphanNodes]\n  )\n\n  return (\n    <Popup\n      position='down'\n      alignment='end'\n      isVisible={isVisible}\n      onRequestClose={onRequestClose}\n      anchorRef={anchorRef}\n      transparent\n      hideArrow\n      overlayCloseOnClick\n      contentClassName='rounded-default'\n    >\n      <div className='rounded-default p-8 space-y-8 w-320 bg-white border border-gray-300 overflow-hidden text-gray-500'>\n        {!orphanNodes.length && (\n          <div className='flex flex-col items-center justify-center text-center py-20 space-y-4'>\n            <Icon className='text-blue-500 s-28'>\n              <FiInbox />\n            </Icon>\n            <div className='text-heading-2 font-medium'>Spick and span!</div>\n            <div className='text-subhead'>\n              Choose the <span className='text-blue-500'>Save to Icebox</span>{' '}\n              option to create standalone editables that do not appear in the\n              document.\n            </div>\n          </div>\n        )}\n        <div className='space-y-4'>\n          {orphanNodes.map(({ id, defaultValue }) => (\n            <div\n              key={id as any}\n              className='rounded-default bg-blue-500 text-white font-medium px-8 py-8 flex items-center'\n            >\n              <div className='flex-1'>{defaultValue}</div>\n              <Icon\n                onPress={() => handlePressDelete(id as any)}\n                className='cursor-pointer text-white opacity-50 transition-opacity duration-250 hover:opacity-100'\n              >\n                <FaRegTrashAlt />\n              </Icon>\n            </div>\n          ))}\n        </div>\n      </div>\n    </Popup>\n  )\n}\n\nexport default OrphanNodesPopup\n","import React, {\n  FC,\n  MutableRefObject,\n  PropsWithChildren,\n  useCallback\n} from 'react'\nimport Popup from '../../popup'\nimport classnames from 'classnames'\nimport { HeadingFormatType } from '../../../core/tools'\nimport { nil } from '../../../core/utils'\nimport { useMouseDown } from '../../../core/hooks'\n\ntype TextSizePopupProps = {\n  anchorRef: MutableRefObject<Element>\n  isVisible: boolean\n  value: HeadingFormatType\n  onPressOption?: (value: HeadingFormatType) => void\n  onRequestClose: Fn\n}\n\ntype TextSizeOptionProps = PropsWithChildren<{\n  active?: boolean\n  onPress?: Fn\n}>\n\nconst TextSizeOption: FC<TextSizeOptionProps> = ({\n  active,\n  children,\n  onPress\n}) => {\n  const handlePress = useMouseDown(onPress)\n\n  return (\n    <div\n      className={classnames(\n        'cursor-pointer h-40 px-20 flex items-center font-medium bg-transparent transition-colors duration-250 hover:bg-blue-100 hover:text-blue-500',\n        {\n          'text-blue-500 bg-blue-highlight': active\n        }\n      )}\n      onMouseDown={handlePress}\n    >\n      {children}\n    </div>\n  )\n}\n\nconst TextSizePopup: FC<TextSizePopupProps> = ({\n  anchorRef,\n  isVisible,\n  value,\n  onPressOption,\n  onRequestClose\n}) => {\n  const handlePressOption = useCallback(\n    (option?: HeadingFormatType) => {\n      onPressOption?.(option)\n      onRequestClose?.()\n    },\n    [onPressOption, onRequestClose]\n  )\n\n  return (\n    <Popup\n      position='down'\n      alignment='start'\n      isVisible={isVisible}\n      onRequestClose={onRequestClose}\n      anchorRef={anchorRef}\n      transparent\n      hideArrow\n      overlayCloseOnClick\n      contentClassName='rounded-default'\n    >\n      <div className='rounded-default w-144 bg-white border border-gray-300 overflow-hidden text-gray-500'>\n        <TextSizeOption active={nil(value)} onPress={() => handlePressOption()}>\n          <span className='-ml-1'>Normal</span>\n        </TextSizeOption>\n        <TextSizeOption\n          active={value === 'heading-three'}\n          onPress={() => handlePressOption('heading-three')}\n        >\n          <span className='text-headline -ml-1'>Heading 3</span>\n        </TextSizeOption>\n        <TextSizeOption\n          active={value === 'heading-two'}\n          onPress={() => handlePressOption('heading-two')}\n        >\n          <span className='text-heading-3 -ml-1'>Heading 2</span>\n        </TextSizeOption>\n        <TextSizeOption\n          active={value === 'heading-one'}\n          onPress={() => handlePressOption('heading-one')}\n        >\n          <span className='text-heading-2 -ml-1'>Heading 1</span>\n        </TextSizeOption>\n      </div>\n    </Popup>\n  )\n}\n\nexport default TextSizePopup\n","import {\n  BlockAlignment,\n  EditableAttributes,\n  EditableRefAttributes,\n  HeadingFormatType,\n  LeafFormatType,\n  createEditableNode,\n  decreaseIndentation,\n  focusEditor,\n  increaseIndentation,\n  insertEditableBlock,\n  insertImageBlock,\n  insertTableBlock,\n  isBlockActive,\n  isMarkActive,\n  setAlignment,\n  setConditionActive,\n  toggleBlockActive,\n  toggleColorMarkActive,\n  toggleMarkActive,\n  unsetConditionActive\n} from '../../core/tools'\nimport { ImageDimensions, nil, notNil } from '../../core/utils'\nimport ImagePopup, { ImageProps } from '../popups/image'\nimport React, { FC, Fragment, useCallback, useRef } from 'react'\nimport {\n  useAlignmentValue,\n  useCanRedo,\n  useCanUndo,\n  useConditionActive,\n  useEditor,\n  useLeafColorValue,\n  useMouseDown,\n  useOrphanNodes,\n  usePopupUtils,\n  useTextSizeValue\n} from '../../core/hooks'\n\nimport { ALIGNMENTS } from '../../core/constants'\nimport { AiOutlineTable } from '@react-icons/all-files/ai/AiOutlineTable'\nimport ColorPopup from '../popups/color'\nimport ConditionPopup from '../popups/condition'\nimport EditablePopupProps from '../popups/editable'\nimport { FiInbox } from '@react-icons/all-files/fi/FiInbox'\nimport { GrRedo } from '@react-icons/all-files/gr/GrRedo'\nimport { GrUndo } from '@react-icons/all-files/gr/GrUndo'\nimport { HistoryEditor } from 'slate-history'\nimport Icon from '../icon'\nimport IconButton from '../icon-button'\nimport IconGroup from '../icon-group'\nimport ImageSizePopup from '../popups/image-size'\nimport { MdFormatAlignCenter } from '@react-icons/all-files/md/MdFormatAlignCenter'\nimport { MdFormatAlignJustify } from '@react-icons/all-files/md/MdFormatAlignJustify'\nimport { MdFormatAlignLeft } from '@react-icons/all-files/md/MdFormatAlignLeft'\nimport { MdFormatAlignRight } from '@react-icons/all-files/md/MdFormatAlignRight'\nimport { MdFormatBold } from '@react-icons/all-files/md/MdFormatBold'\nimport { MdFormatIndentDecrease } from '@react-icons/all-files/md/MdFormatIndentDecrease'\nimport { MdFormatIndentIncrease } from '@react-icons/all-files/md/MdFormatIndentIncrease'\nimport { MdFormatItalic } from '@react-icons/all-files/md/MdFormatItalic'\nimport { MdFormatListBulleted } from '@react-icons/all-files/md/MdFormatListBulleted'\nimport { MdFormatListNumbered } from '@react-icons/all-files/md/MdFormatListNumbered'\nimport { MdFormatSize } from '@react-icons/all-files/md/MdFormatSize'\nimport { MdFormatStrikethrough } from '@react-icons/all-files/md/MdFormatStrikethrough'\nimport { MdFormatUnderlined } from '@react-icons/all-files/md/MdFormatUnderlined'\nimport { MdTextFields } from '@react-icons/all-files/md/MdTextFields'\nimport { MdTransform } from '@react-icons/all-files/md/MdTransform'\nimport OrphanNodesPopup from '../popups/orphan-nodes'\nimport { RiImage2Fill } from '@react-icons/all-files/ri/RiImage2Fill'\nimport { RiImageEditFill } from '@react-icons/all-files/ri/RiImageEditFill'\nimport TextSizePopup from '../popups/text-size'\nimport { Transforms } from 'slate'\nimport classnames from 'classnames'\n\nconst Toolbar: FC = () => {\n  const editor = useEditor()\n  const editorSelection = useRef(editor.selection)\n\n  const textSizePopupAnchorRef = useRef(null)\n  const colorPopupAnchorRef = useRef(null)\n  const imagePopupAnchorRef = useRef(null)\n  const imageSizePopupAnchorRef = useRef(null)\n  const conditionPopupAnchorRef = useRef(null)\n  const orphanNodesPopupAnchorRef = useRef(null)\n\n  const textSizePopup = usePopupUtils()\n  const colorPopup = usePopupUtils()\n  const imagePopup = usePopupUtils()\n  const imageSizePopup = usePopupUtils()\n  const editablePopup = usePopupUtils()\n  const conditionPopup = usePopupUtils()\n  const orphanNodesPopup = usePopupUtils()\n\n  const textSizeValue = useTextSizeValue()\n  const leafColorValue = useLeafColorValue()\n  const alignmentValue = useAlignmentValue()\n  const canUndo = useCanUndo()\n  const canRedo = useCanRedo()\n  const conditionActive = useConditionActive()\n\n  const [, setOrphanNodes] = useOrphanNodes()\n\n  const handleChangeTextSizeOption = useCallback(\n    (value: HeadingFormatType) => {\n      const prevValue = textSizeValue?.name\n\n      if (value === prevValue) {\n        return\n      }\n\n      if (notNil(prevValue)) {\n        toggleBlockActive(editor, prevValue)\n      }\n\n      if (notNil(value)) {\n        toggleBlockActive(editor, value)\n      }\n\n      focusEditor(editor)\n    },\n    [editor, textSizeValue]\n  )\n\n  const handleChangeColorOption = useCallback(\n    (value: string, focus = true) => {\n      const prevValue = leafColorValue\n\n      if (value === prevValue) {\n        return\n      }\n\n      if (notNil(editorSelection.current)) {\n        Transforms.select(editor, editorSelection.current)\n      }\n\n      if (notNil(prevValue)) {\n        toggleColorMarkActive(editor, prevValue)\n      }\n\n      if (notNil(value)) {\n        toggleColorMarkActive(editor, value)\n      }\n\n      editorSelection.current = editor.selection\n\n      if (focus) {\n        focusEditor(editor)\n      }\n    },\n    [editor, leafColorValue]\n  )\n\n  const handleCreateImage = useCallback(\n    (value: ImageProps) => {\n      if (notNil(editorSelection.current)) {\n        Transforms.select(editor, editorSelection.current)\n      }\n\n      insertImageBlock(editor, value)\n      focusEditor(editor)\n    },\n    [editor]\n  )\n\n  const handleCreateEditableImage = useCallback(\n    (value: ImageDimensions, label: string) => {\n      if (notNil(editorSelection.current)) {\n        Transforms.select(editor, editorSelection.current)\n      }\n\n      insertImageBlock(editor, { dimensions: value, label }, true)\n      focusEditor(editor)\n    },\n    [editor]\n  )\n\n  const handleCreateEditable = useCallback(\n    (value: EditableAttributes, isOrphan = false) => {\n      if (notNil(editorSelection.current)) {\n        Transforms.select(editor, editorSelection.current)\n      }\n\n      if (isOrphan) {\n        const editableNode = createEditableNode(value, true)\n        setOrphanNodes((o) => [editableNode, ...o])\n      } else {\n        insertEditableBlock(editor, value)\n      }\n\n      focusEditor(editor)\n    },\n    [editor, setOrphanNodes]\n  )\n\n  const handleSetConditionActive = useCallback(\n    (value: EditableRefAttributes) => {\n      if (notNil(editorSelection.current)) {\n        Transforms.select(editor, editorSelection.current)\n      }\n\n      setConditionActive(editor, value)\n      focusEditor(editor)\n    },\n    [editor]\n  )\n\n  const handlePressTextSize = useMouseDown(() => {\n    textSizePopup.open()\n  })\n\n  const handlePressColor = useMouseDown(() => {\n    editorSelection.current = editor.selection\n    colorPopup.open()\n  })\n\n  const handlePressImage = useMouseDown(() => {\n    editorSelection.current = editor.selection\n    imagePopup.open()\n  })\n\n  const handlePressEditableImage = useMouseDown(() => {\n    editorSelection.current = editor.selection\n    imageSizePopup.open()\n  })\n\n  const handlePressInsertEditable = useMouseDown(() => {\n    editorSelection.current = editor.selection\n    editablePopup.open()\n  })\n\n  const handlePressInsertTable = useMouseDown(() => {\n    insertTableBlock(editor)\n  })\n\n  const handlePressCondition = useMouseDown(() => {\n    if (conditionActive) {\n      unsetConditionActive(editor)\n      return\n    }\n\n    editorSelection.current = editor.selection\n    conditionPopup.open()\n  })\n\n  const handlePressInlineFormat = useCallback(\n    (format: LeafFormatType) => {\n      toggleMarkActive(editor, format)\n    },\n    [editor]\n  )\n\n  const handlePressAlignment = useCallback(\n    (value?: BlockAlignment) => {\n      setAlignment(editor, value)\n    },\n    [editor]\n  )\n\n  const handlePressIncreaseIndentation = useCallback(() => {\n    increaseIndentation(editor)\n  }, [editor])\n\n  const handlePressDecreaseIndentation = useCallback(() => {\n    decreaseIndentation(editor)\n  }, [editor])\n\n  const handlePressNumberedList = useCallback(() => {\n    toggleBlockActive(editor, 'numbered-list')\n  }, [editor])\n\n  const handlePressBulletedList = useCallback(() => {\n    toggleBlockActive(editor, 'bulleted-list')\n  }, [editor])\n\n  const handlePressUndo = useCallback(() => {\n    HistoryEditor.undo(editor)\n  }, [editor])\n\n  const handlePressRedo = useCallback(() => {\n    HistoryEditor.redo(editor)\n  }, [editor])\n\n  return (\n    <Fragment>\n      <div className='border-t border-b border-solid border-gray-300 py-20 px-60 bg-blue-50 flex items-center divide-x divide-gray-300 text-gray-500'>\n        <div className='font-medium flex items-center'>\n          <div\n            ref={textSizePopupAnchorRef}\n            className='flex items-center w-144 space-x-4 flex-1'\n            onMouseDown={handlePressTextSize}\n          >\n            <Icon>\n              <MdFormatSize />\n            </Icon>\n            <span className='flex-1 cursor-pointer transition-colors duration-250 hover:text-blue-500'>\n              {textSizeValue?.label || 'Normal'}\n            </span>\n          </div>\n          <div\n            ref={colorPopupAnchorRef}\n            className={classnames(\n              's-28 cursor-pointer border-2 border-solid border-white mx-16 rounded-full shadow-2 transition-colors duration-250',\n              {\n                'bg-black': nil(leafColorValue)\n              }\n            )}\n            style={{ backgroundColor: leafColorValue }}\n            onMouseDown={handlePressColor}\n          />\n        </div>\n        <IconGroup>\n          <IconButton\n            data='bold'\n            tip='Bold'\n            active={isMarkActive(editor, 'bold')}\n            onPress={handlePressInlineFormat}\n          >\n            <MdFormatBold />\n          </IconButton>\n          <IconButton\n            data='italic'\n            tip='Italic'\n            active={isMarkActive(editor, 'italic')}\n            onPress={handlePressInlineFormat}\n          >\n            <MdFormatItalic />\n          </IconButton>\n          <IconButton\n            data='underline'\n            tip='Underline'\n            active={isMarkActive(editor, 'underline')}\n            onPress={handlePressInlineFormat}\n          >\n            <MdFormatUnderlined />\n          </IconButton>\n          <IconButton\n            data='strikethrough'\n            tip='Strikethrough'\n            active={isMarkActive(editor, 'strikethrough')}\n            onPress={handlePressInlineFormat}\n          >\n            <MdFormatStrikethrough />\n          </IconButton>\n        </IconGroup>\n        <IconGroup>\n          <IconButton\n            tip='Align left'\n            active={nil(alignmentValue) || alignmentValue === ALIGNMENTS.left}\n            onPress={handlePressAlignment}\n          >\n            <MdFormatAlignLeft />\n          </IconButton>\n          <IconButton\n            data='center'\n            tip='Align center'\n            active={alignmentValue === ALIGNMENTS.center}\n            onPress={handlePressAlignment}\n          >\n            <MdFormatAlignCenter />\n          </IconButton>\n          <IconButton\n            data='right'\n            tip='Align right'\n            active={alignmentValue === ALIGNMENTS.right}\n            onPress={handlePressAlignment}\n          >\n            <MdFormatAlignRight />\n          </IconButton>\n          <IconButton\n            data='justify'\n            tip='Justify'\n            active={alignmentValue === ALIGNMENTS.justify}\n            onPress={handlePressAlignment}\n          >\n            <MdFormatAlignJustify />\n          </IconButton>\n        </IconGroup>\n        <IconGroup>\n          <IconButton\n            tip='Decrease indent'\n            onPress={handlePressDecreaseIndentation}\n          >\n            <MdFormatIndentDecrease />\n          </IconButton>\n          <IconButton\n            tip='Increase indent'\n            onPress={handlePressIncreaseIndentation}\n          >\n            <MdFormatIndentIncrease />\n          </IconButton>\n        </IconGroup>\n        <IconGroup>\n          <IconButton\n            tip='Numbered list'\n            active={isBlockActive(editor, 'numbered-list')}\n            onPress={handlePressNumberedList}\n          >\n            <MdFormatListNumbered />\n          </IconButton>\n          <IconButton\n            tip='Bulleted list'\n            active={isBlockActive(editor, 'bulleted-list')}\n            onPress={handlePressBulletedList}\n          >\n            <MdFormatListBulleted />\n          </IconButton>\n        </IconGroup>\n        <IconGroup>\n          <IconButton\n            tip='Insert an image'\n            ref={imagePopupAnchorRef}\n            active={imagePopup.visible}\n            onPress={handlePressImage}\n          >\n            <RiImage2Fill />\n          </IconButton>\n          <IconButton tip='Insert a table' onPress={handlePressInsertTable}>\n            <AiOutlineTable />\n          </IconButton>\n        </IconGroup>\n        <IconGroup>\n          <IconButton\n            tip='Insert an editable image'\n            ref={imageSizePopupAnchorRef}\n            active={imageSizePopup.visible}\n            onPress={handlePressEditableImage}\n            className='border border-dotted border-gray-500'\n          >\n            <RiImageEditFill />\n          </IconButton>\n          <IconButton\n            tip='Insert editable content'\n            active={editablePopup.visible}\n            className='border border-dotted border-gray-500'\n            onPress={handlePressInsertEditable}\n          >\n            <MdTextFields />\n          </IconButton>\n          <IconButton\n            tip='Add a display condition'\n            ref={conditionPopupAnchorRef}\n            active={conditionActive || conditionPopup.visible}\n            onPress={handlePressCondition}\n            className='border border-dotted border-gray-500'\n          >\n            <MdTransform />\n          </IconButton>\n        </IconGroup>\n        <IconGroup>\n          <IconButton tip='Undo' onPress={handlePressUndo} disabled={!canUndo}>\n            <GrUndo />\n          </IconButton>\n          <IconButton tip='Redo' onPress={handlePressRedo} disabled={!canRedo}>\n            <GrRedo />\n          </IconButton>\n        </IconGroup>\n        <div className='flex flex-1 items-center justify-end border-none'>\n          <IconButton\n            tip='Open Icebox'\n            ref={orphanNodesPopupAnchorRef}\n            active={orphanNodesPopup.visible}\n            onPress={orphanNodesPopup.open}\n          >\n            <FiInbox />\n          </IconButton>\n        </div>\n      </div>\n      <TextSizePopup\n        anchorRef={textSizePopupAnchorRef}\n        isVisible={textSizePopup.visible}\n        value={textSizeValue?.name}\n        onPressOption={handleChangeTextSizeOption}\n        onRequestClose={textSizePopup.close}\n      />\n      <ColorPopup\n        anchorRef={colorPopupAnchorRef}\n        isVisible={colorPopup.visible}\n        value={leafColorValue}\n        onChangeColorOption={handleChangeColorOption}\n        onRequestClose={colorPopup.close}\n      />\n      <ImagePopup\n        anchorRef={imagePopupAnchorRef}\n        isVisible={imagePopup.visible}\n        onRequestClose={imagePopup.close}\n        onSubmitEditing={handleCreateImage}\n      />\n      <ImageSizePopup\n        anchorRef={imageSizePopupAnchorRef}\n        isVisible={imageSizePopup.visible}\n        onRequestClose={imageSizePopup.close}\n        onSubmitEditing={handleCreateEditableImage}\n      />\n      <EditablePopupProps\n        isVisible={editablePopup.visible}\n        onRequestClose={editablePopup.close}\n        onSubmit={handleCreateEditable}\n      />\n      <ConditionPopup\n        anchorRef={conditionPopupAnchorRef}\n        isVisible={conditionPopup.visible}\n        onRequestClose={conditionPopup.close}\n        onSubmitEditing={handleSetConditionActive}\n      />\n      <OrphanNodesPopup\n        anchorRef={orphanNodesPopupAnchorRef}\n        isVisible={orphanNodesPopup.visible}\n        onRequestClose={orphanNodesPopup.close}\n      />\n    </Fragment>\n  )\n}\n\nexport default Toolbar\n","import { Editor, Element as SlateElement, Text, Transforms } from 'slate'\n\nimport { ReactEditor } from 'slate-react'\nimport { jsx } from 'slate-hyperscript'\n\nconst ELEMENT_TAGS = {\n  A: (element: Element) => ({\n    type: 'link',\n    url: element.getAttribute('href')\n  }),\n  BLOCKQUOTE: () => ({ type: 'quote' }),\n  H1: () => ({ type: 'heading-one' }),\n  H2: () => ({ type: 'heading-two' }),\n  H3: () => ({ type: 'heading-three' }),\n  H4: () => ({ type: 'heading-four' }),\n  H5: () => ({ type: 'heading-five' }),\n  H6: () => ({ type: 'heading-six' }),\n  IMG: (element: Element) => ({\n    type: 'image',\n    url: element.getAttribute('src')\n  }),\n  LI: () => ({ type: 'list-item' }),\n  OL: () => ({ type: 'numbered-list' }),\n  P: () => {\n    return { type: 'paragraph' }\n  },\n  PRE: () => ({ type: 'code' }),\n  UL: () => ({ type: 'bulleted-list' }),\n  TABLE: () => ({ type: 'table' }),\n  TH: () => ({ type: 'table-row' }),\n  TR: () => ({ type: 'table-row' }),\n  TD: () => ({ type: 'table-cell' })\n}\n\nconst TEXT_TAGS = {\n  CODE: () => ({ code: true }),\n  DEL: () => ({ strikethrough: true }),\n  EM: () => ({ italic: true }),\n  I: () => ({ italic: true }),\n  S: () => ({ strikethrough: true }),\n  STRONG: () => ({ bold: true }),\n  U: () => ({ underline: true })\n}\n\nconst getMappedAttributes = (node: ChildNode) => {\n  const { nodeName } = node\n\n  if (nodeName === 'BODY') {\n    return {}\n  }\n\n  if (ELEMENT_TAGS[nodeName]) {\n    return ELEMENT_TAGS[nodeName](node)\n  }\n\n  if (TEXT_TAGS[nodeName]) {\n    return TEXT_TAGS[nodeName](node)\n  }\n\n  return null\n}\n\nconst getTagName = (node: ChildNode) => {\n  const { nodeName } = node\n\n  if (nodeName === 'BODY') {\n    return 'fragment'\n  }\n\n  if (ELEMENT_TAGS[nodeName]) {\n    return 'element'\n  }\n\n  if (TEXT_TAGS[nodeName]) {\n    return 'text'\n  }\n\n  return null\n}\n\nconst getChildNodes = (node: ChildNode) => {\n  if (node.nodeName === 'TABLE') {\n    const childNodes: Array<ChildNode> = []\n\n    node.childNodes.forEach((o) => {\n      const { nodeName } = o\n\n      if (['THEAD', 'TBODY'].includes(nodeName)) {\n        childNodes.push(...o.childNodes)\n      } else {\n        childNodes.push(o)\n      }\n    })\n  }\n\n  return Array.from(node.childNodes)\n}\n\nexport const deserializeHTMLNew = (node: ChildNode) => {\n  const { nodeType, nodeName, textContent } = node\n  const validNodeTypes = [1, 3]\n\n  if (!validNodeTypes.includes(nodeType)) {\n    return null\n  }\n\n  if (nodeType === 3) {\n    const sanitized = textContent.replace(/\\n/g, ' ')\n    const result = sanitized.trim().length ? sanitized : null\n    return result\n  }\n\n  if (nodeName === 'BR') {\n    return '\\n'\n  }\n\n  const tagName = getTagName(node)\n  const attrs = getMappedAttributes(node)\n  const childNodes = getChildNodes(node)\n  const deserializedChildren = childNodes\n    .map((o) => deserializeHTMLNew(o))\n    .flat()\n\n  if (!tagName) {\n    return deserializedChildren\n  }\n\n  if (!deserializedChildren.length) {\n    return null\n  }\n\n  return jsx(tagName, attrs, deserializedChildren)\n}\n\nexport const deserializeHTML = (el: ChildNode) => {\n  if (el.nodeType === 3) {\n    const sanitized = el.textContent.replace(/\\n/g, ' ')\n    const result = sanitized.trim().length ? sanitized : null\n    return result\n  } else if (el.nodeType !== 1) {\n    return null\n  } else if (el.nodeName === 'BR') {\n    return '\\n'\n  }\n\n  const { nodeName } = el\n  let parent = el\n\n  if (\n    nodeName === 'PRE' &&\n    el.childNodes[0] &&\n    el.childNodes[0].nodeName === 'CODE'\n  ) {\n    parent = el.childNodes[0]\n  }\n\n  const children = Array.from(parent.childNodes).map(deserializeHTML).flat()\n\n  if (el.nodeName === 'BODY') {\n    return jsx('fragment', {}, children)\n  }\n\n  if (ELEMENT_TAGS[nodeName]) {\n    const attrs = ELEMENT_TAGS[nodeName](el)\n    return jsx('element', attrs, children)\n  }\n\n  if (TEXT_TAGS[nodeName]) {\n    const attrs = TEXT_TAGS[nodeName](el)\n    return children.map((child) => jsx('text', attrs, child))\n  }\n\n  return children\n}\n\nconst wrapTopLevelInlineNodesInParagraphs = (editor, fragment) => {\n  let inlineNodes = []\n  const newFragments = []\n\n  const maybePushInlineNodeParagraph = () => {\n    if (inlineNodes.length > 0) {\n      newFragments.push(jsx('element', { type: 'paragraph' }, inlineNodes))\n      inlineNodes = []\n    }\n  }\n\n  fragment.forEach((node) => {\n    if (Text.isText(node) || Editor.isInline(editor, node)) {\n      inlineNodes.push(node)\n    } else {\n      maybePushInlineNodeParagraph()\n      newFragments.push(node)\n    }\n  })\n  maybePushInlineNodeParagraph()\n\n  return newFragments\n}\n\nexport const withHTML = (editor: Editor & ReactEditor) => {\n  const { insertData, isInline, isVoid } = editor\n\n  editor.isInline = (element: SlateElement) => {\n    return ['link', 'image'].includes(element.type as string)\n      ? true\n      : isInline(element)\n  }\n\n  editor.isVoid = (element) => {\n    return element.type === 'image' ? true : isVoid(element)\n  }\n\n  editor.insertData = (data) => {\n    const html = data.getData('text/html')\n\n    if (html) {\n      const parsed = new DOMParser().parseFromString(html, 'text/html')\n      const fragment = deserializeHTML(parsed.body)\n      let fragmentWithOnlyBlocks = fragment\n      if (Array.isArray(fragment)) {\n        fragmentWithOnlyBlocks = wrapTopLevelInlineNodesInParagraphs(\n          editor,\n          fragment\n        )\n      }\n      Transforms.insertFragment(editor, fragmentWithOnlyBlocks)\n      return\n    }\n\n    insertData(data)\n  }\n\n  return editor\n}\n","import { Editor, NodeEntry, Path, Range, Transforms } from 'slate'\nimport { createTableContent, insertParagraph, isInSameTable } from '../tools'\n\nimport { ReactEditor } from 'slate-react'\n\nexport const PreserveSpaceAfter = new Set<any>(['table'])\n\nexport const PreserveSpaceBefore = new Set<any>(['table'])\n\nconst shouldPreserveSpace = (\n  editor: Editor & ReactEditor,\n  entry: NodeEntry\n): boolean | void => {\n  const [node, path] = entry\n  const { type } = node\n  let preserved = false\n\n  if (PreserveSpaceAfter.has(type)) {\n    const next = Editor.next(editor, { at: path })\n    if (!next || PreserveSpaceBefore.has(next[0].type)) {\n      insertParagraph(editor, Path.next(path))\n      preserved = true\n    }\n  }\n\n  if (PreserveSpaceBefore.has(type)) {\n    if (path[path.length - 1] === 0) {\n      insertParagraph(editor, path)\n      preserved = true\n    } else {\n      const prev = Editor.previous(editor, { at: path })\n      if (!prev || PreserveSpaceAfter.has(prev[0].type)) {\n        insertParagraph(editor, path)\n        preserved = true\n      }\n    }\n  }\n\n  return preserved\n}\n\nexport const withTable = (editor: Editor & ReactEditor) => {\n  const { addMark, removeMark, deleteBackward, deleteFragment } = editor\n\n  editor.addMark = (key, value) => {\n    if (editor.selection) {\n      const lastSelection = editor.selection\n\n      const selectedCells = Editor.nodes(editor, {\n        match: (n) => n.selectedCell as any,\n        at: []\n      })\n\n      let isTable = false\n\n      for (const cell of selectedCells) {\n        if (!isTable) {\n          isTable = true\n        }\n\n        const [content] = Editor.nodes(editor, {\n          match: (n) => n.type === 'table-content',\n          at: cell[1]\n        })\n\n        if (Editor.string(editor, content[1]) !== '') {\n          Transforms.setSelection(editor, Editor.range(editor, cell[1]))\n          addMark(key, value)\n        }\n      }\n\n      if (isTable) {\n        Transforms.select(editor, lastSelection)\n        return\n      }\n    }\n\n    addMark(key, value)\n  }\n\n  editor.removeMark = (key) => {\n    if (editor.selection) {\n      const lastSelection = editor.selection\n      const selectedCells = Editor.nodes(editor, {\n        match: (n) => {\n          return n.selectedCell as any\n        },\n        at: []\n      })\n\n      let isTable = false\n      for (const cell of selectedCells) {\n        if (!isTable) {\n          isTable = true\n        }\n\n        const [content] = Editor.nodes(editor, {\n          match: (n) => n.type === 'table-content',\n          at: cell[1]\n        })\n\n        if (Editor.string(editor, content[1]) !== '') {\n          Transforms.setSelection(editor, Editor.range(editor, cell[1]))\n          removeMark(key)\n        }\n      }\n\n      if (isTable) {\n        Transforms.select(editor, lastSelection)\n        return\n      }\n    }\n    removeMark(key)\n  }\n\n  editor.deleteFragment = (...args) => {\n    if (editor.selection && isInSameTable(editor)) {\n      const selectedCells = Editor.nodes(editor, {\n        match: (n) => {\n          return n.selectedCell as any\n        }\n      })\n\n      for (const cell of selectedCells) {\n        Transforms.setSelection(editor, Editor.range(editor, cell[1]))\n\n        const [content] = Editor.nodes(editor, {\n          match: (n) => n.type === 'table-content'\n        })\n\n        Transforms.insertNodes(editor, createTableContent(), { at: content[1] })\n        Transforms.removeNodes(editor, { at: Path.next(content[1]) })\n      }\n\n      return\n    }\n\n    Transforms.removeNodes(editor, {\n      match: (n) => n.type === 'table'\n    })\n\n    deleteFragment(...args)\n  }\n\n  editor.deleteBackward = (...args) => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const isInTable = Editor.above(editor, {\n        match: (n) => n.type === 'table'\n      })\n\n      if (isInTable) {\n        const start = Editor.start(editor, selection)\n        const isStart = Editor.isStart(editor, start, selection)\n\n        const currCell = Editor.above(editor, {\n          match: (n) => n.type === 'table-cell'\n        })\n\n        if (isStart && currCell && !Editor.string(editor, currCell[1])) {\n          return\n        }\n      }\n    }\n\n    deleteBackward(...args)\n  }\n\n  return editor\n}\n\nexport const withSchema = (editor: Editor & ReactEditor) => {\n  const { normalizeNode } = editor\n\n  editor.normalizeNode = (entry) => {\n    if (shouldPreserveSpace(editor, entry)) return\n\n    normalizeNode(entry)\n  }\n\n  return withTable(editor)\n}\n","import 'tailwindcss/tailwind.css'\n\nimport { DocmakerData, SlateEditorType, toggleMarkActive } from './core/tools'\nimport { Editable, Slate, withReact } from 'slate-react'\nimport { Node, createEditor } from 'slate'\nimport React, {\n  KeyboardEvent,\n  useCallback,\n  useMemo,\n  useRef,\n  useState\n} from 'react'\nimport { stripHTMLEntities, toDate } from './core/utils'\n\nimport { HOT_KEYS } from './core/constants'\nimport Header from './modules/header'\nimport OrphanNodesContext from './core/contexts/orphan-nodes'\nimport TemplateEditor from './modules/template-editor'\nimport TemplateElement from './modules/template-element'\nimport TemplateLeaf from './modules/template-leaf'\nimport Toolbar from './modules/toolbar'\nimport classnames from 'classnames'\nimport isHotkey from 'is-hotkey'\nimport { withEditable } from './core/plugins/editable'\nimport { withHTML } from './core/plugins/paste-html'\nimport { withHistory } from 'slate-history'\nimport { withSchema } from './core/plugins/table'\n\ninterface Props {\n  className?: string\n  initialValue?: DocmakerData\n  onSubmitChanges?: (data: DocmakerData) => void\n}\n\nexport const DocmakerEditor = ({\n  className,\n  initialValue,\n  onSubmitChanges\n}: Props) => {\n  const initialData = useRef(initialValue || ({} as DocmakerData)).current\n  const editor = useMemo(\n    () =>\n      withSchema(\n        withHTML(withEditable(withReact(withHistory(createEditor()))))\n      ),\n    []\n  )\n  const createdAt = useRef(toDate(initialData.createdAt).toISOString()).current\n\n  const [title, setTitle] = useState(initialData.title || '')\n  const [orphanNodes, setOrphanNodes] = useState<Array<Node>>(\n    initialData.orphans || []\n  )\n  const [editorState, setEditorState] = useState<Array<Node>>(\n    initialData.nodes?.length\n      ? initialData.nodes\n      : [\n          {\n            type: 'paragraph',\n            children: [{ text: '' }]\n          }\n        ]\n  )\n\n  const renderElement = useCallback(\n    (props) => <TemplateElement {...props} />,\n    []\n  )\n\n  const renderLeaf = useCallback((props) => <TemplateLeaf {...props} />, [])\n\n  const handleEditorKeydown = useCallback(\n    (event: KeyboardEvent) => {\n      for (const hotkey in HOT_KEYS) {\n        if (isHotkey(hotkey, event as any)) {\n          event.preventDefault()\n          const mark = HOT_KEYS[hotkey]\n          toggleMarkActive(editor as SlateEditorType, mark)\n        }\n      }\n    },\n    [editor]\n  )\n\n  const handlePressSave = useCallback(() => {\n    onSubmitChanges?.({\n      title: stripHTMLEntities(title),\n      createdAt,\n      nodes: editorState as any,\n      orphans: orphanNodes as any\n    })\n  }, [onSubmitChanges, title, createdAt, editorState, orphanNodes])\n\n  return (\n    <div className={classnames('font-sans', className)}>\n      <OrphanNodesContext.Provider value={[orphanNodes, setOrphanNodes]}>\n        <Slate editor={editor} value={editorState} onChange={setEditorState}>\n          <div className='sticky top-0'>\n            <Header\n              title={title}\n              createdAt={createdAt}\n              onChangeTitle={setTitle}\n              onPressSave={handlePressSave}\n            />\n            <Toolbar />\n          </div>\n          <TemplateEditor>\n            <Editable\n              spellCheck\n              placeholder='Start typing...'\n              renderElement={renderElement}\n              renderLeaf={renderLeaf}\n              onKeyDown={handleEditorKeydown}\n            />\n          </TemplateEditor>\n          <div id='docmaker-modal-root' />\n        </Slate>\n      </OrphanNodesContext.Provider>\n    </div>\n  )\n}\n","import { Editor, Element as SlateElement } from 'slate'\nimport { ReactEditor } from 'slate-react'\n\nexport const withEditable = (editor: Editor & ReactEditor) => {\n  const { isInline, isVoid } = editor\n\n  editor.isInline = (element: SlateElement) => {\n    return element.type === 'editable' ? true : isInline(element)\n  }\n\n  editor.isVoid = (element: SlateElement) => {\n    return element.type === 'editable' ? true : isVoid(element)\n  }\n\n  return editor\n}\n","import React from 'react'\n\nimport { DocmakerEditor } from 'react-docmaker'\nimport 'react-docmaker/dist/index.css'\n\nconst App = () => {\n  return <DocmakerEditor onSubmitChanges={console.log} />\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}